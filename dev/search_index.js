var documenterSearchIndex = {"docs":
[{"location":"public_api/#SDiagonalizability.jl-–-Public-API","page":"Public API","title":"SDiagonalizability.jl – Public API","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"Documentation for SDiagonalizability's public API.","category":"page"},{"location":"public_api/","page":"Public API","title":"Public API","text":"note: Note\nThe following documentation covers only the public API of the package. For internal details, see the private API documentation.","category":"page"},{"location":"public_api/#SDiagonalizability.SDiagonalizability","page":"Public API","title":"SDiagonalizability.SDiagonalizability","text":"SDiagonalizability\n\nA dynamic algorithm to minimize or recognize the S-bandwidth of an undirected graph.\n\nGiven an undirected, possibly weighted graph G and finite set of integers S ⊂ ℤ, G is said to be \"S-diagonalizable\" if there exists some diagonal matrix D and matrix P with all entries from S such that G's Laplacian matrix L(G) = PDP¹. If G is S-diagonalizable, then its \"S-bandwidth\" is the minimum integer k  1 2  V(G) such that there exists some diagonal matrix D and matrix P with all entries from S such that L(G) = PDP¹ and PᵀPᵢⱼ = 0 whenever i - j  k; otherwise, its S-bandwidth is simply .\n\nFor specific choices of S (namely -1 1 and -1 0 1), the S-bandwidth of a quantum network has been shown to be an indicator of high state transfer fidelity due to automorphic properties of the graph. As such, the nascent study of S-diagonalizability and S-bandwidth is of interest in the broader context of quantum information theory.\n\nThis package, therefore, implements the first algorithm beyond mere brute force to minimize the S-bandwidth of an undirected graph with integer edge weights. Capabilities also exist for determining whether a graph has S-bandwidth less than or equal to a fixed integer k  1 without necessarily caring about the true minimum value.\n\nThe full documentation is available at GitHub Pages.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#SDiagonalizability.has_s_bandwidth_at_most_k-Tuple{Graphs.AbstractGraph, Tuple{Vararg{Integer}}, Integer}","page":"Public API","title":"SDiagonalizability.has_s_bandwidth_at_most_k","text":"has_s_bandwidth_at_most_k(g::AbstractGraph, S, k) -> SBandRecognitionResult\nhas_s_bandwidth_at_most_k(L::AbstractMatrix{<:Integer}, S, k) -> SBandRecognitionResult\n\n[TODO: Write here. Also, comment inline and cite [JP25].]\n\nReferences\n\n[JP25]: N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable   graphs. Linear Algebra and its Applications 704, 309–39 (2025).   https://doi.org/10.1016/j.laa.2024.10.016.\n\n\n\n\n\n","category":"method"},{"location":"public_api/#SDiagonalizability.is_s_diagonalizable-Tuple{Graphs.AbstractGraph, Tuple{Vararg{Integer}}}","page":"Public API","title":"SDiagonalizability.is_s_diagonalizable","text":"is_s_diagonalizable(g::AbstractGraph, S) -> SDiagonalizabilityResult\nis_s_diagonalizable(L::AbstractMatrix{<:Integer}, S) -> SDiagonalizabilityResult\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"public_api/#SDiagonalizability.s_bandwidth-Tuple{Graphs.AbstractGraph, Tuple{Vararg{Integer}}}","page":"Public API","title":"SDiagonalizability.s_bandwidth","text":"s_bandwidth(g::AbstractGraph, S) -> SBandMinimizationResult\ns_bandwidth(L::AbstractMatrix{<:Integer}, S) -> SBandMinimizationResult\n\n[TODO: Write here. Also, comment inline and cite [JP25].]\n\nReferences\n\n[JP25]: N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable   graphs. Linear Algebra and its Applications 704, 309–39 (2025).   https://doi.org/10.1016/j.laa.2024.10.016.\n\n\n\n\n\n","category":"method"},{"location":"public_api/#References","page":"Public API","title":"References","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable graphs. Linear Algebra and its Applications 704, 309–39 (2025).\n\n\n\n","category":"page"},{"location":"private_api/#SDiagonalizability.jl-–-Private-API","page":"Private API","title":"SDiagonalizability.jl – Private API","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"Documentation for SDiagonalizability's private API.","category":"page"},{"location":"private_api/","page":"Private API","title":"Private API","text":"note: Note\nThe following documentation covers only the private API of the package. For public details, see the public API documentation.","category":"page"},{"location":"private_api/#SDiagonalizability.AbstractSDiagResult","page":"Private API","title":"SDiagonalizability.AbstractSDiagResult","text":"AbstractSDiagResult\n\nAbstract base type for all S-diagonalizability and S-bandwidth problem results.\n\nInterface\n\nConcrete subtypes of AbstractSDiagResult must implement parametric types\n\nA<:Union{AbstractGraph,AbstractMatrix{<:Integer}};\nB<:Tuple{Vararg{Integer}}; and\nC<:Union{Nothing,Eigen},\n\nalongside the following fields:\n\nnetwork::A: the network whose S-bandwidth is investigated;\nS::B: the set S from whose entries we are allowed to construct eigenvectors;\ndiagonalization::C: an S-diagonalization of the matrix representation of the network,   if it satisfies the specified S-bandwidth constraints; otherwise, nothing.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.ArbitraryGraphLaplacian","page":"Private API","title":"SDiagonalizability.ArbitraryGraphLaplacian","text":"ArbitraryGraphLaplacian <: ClassifiedLaplacian\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nArbitraryGraphLaplacian <: ClassifiedLaplacian\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.ClassifiedLaplacian","page":"Private API","title":"SDiagonalizability.ClassifiedLaplacian","text":"ClassifiedLaplacian\n\nAn abstract type representing a classified Laplacian matrix of an undirected graph.\n\nInterface\n\nConcrete subtypes of _TypedLaplacian must implement the following fields:\n\nmatrix::Matrix{Int}: the Laplacian matrix of the graph.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.CompleteGraphLaplacian","page":"Private API","title":"SDiagonalizability.CompleteGraphLaplacian","text":"CompleteGraphLaplacian <: ClassifiedLaplacian\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nCompleteGraphLaplacian <: ClassifiedLaplacian\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.EfficiencyWarning","page":"Private API","title":"SDiagonalizability.EfficiencyWarning","text":"EfficiencyWarning(msg)\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.EmptyGraphLaplacian","page":"Private API","title":"SDiagonalizability.EmptyGraphLaplacian","text":"EmptyGraphLaplacian <: ClassifiedLaplacian\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nEmptyGraphLaplacian <: ClassifiedLaplacian\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.KOrthogonality","page":"Private API","title":"SDiagonalizability.KOrthogonality","text":"KOrthogonality\n\nAn abstract type representing the property of k-orthogonality of a collection of vectors.\n\nRecall that an (ordered) collection of vectors v₁ v₂  vₙ is said to be k-orthogonal if we have the inner product vᵢ vⱼ = 0 whenever i - j  k (i.e., if every pair of vectors at least k indices apart is orthogonal). This is equivalent to the vectors' Gram matrix having bandwidth at most k, where we define the bandwidth of a matrix A to be the minimum integer k  1 2  n such that Aᵢⱼ = 0 whenever i - j  k [JP25, p. 313]. (Note that many texts instead define matrix bandwidth using zero-based indexing—that is, with the condition i - j  k [Maf14, p. 186].)\n\nThis type is used as a template for concretely defined properties corresponding to specific values of k. In the context of the overarching S-bandwidth algorithm, we perform a different depth-first search for each family of values of k on our \"tree\" of S-eigenvectors to determine whether there exists a k-orthogonal collection of them.\n\nInterface\n\nConcrete subtypes of KOrthogonality must implement the following fields:\n\nk::Int: the k-orthogonality parameter. Must be a positive integer.\n\nReferences\n\n[JP25]: N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable   graphs. Linear Algebra and its Applications 704, 309–39 (2025).   https://doi.org/10.1016/j.laa.2024.10.016.\n[Maf14]: L. O. Mafteiu-Scai. The Bandwidths of a Matrix. A Survey of Algorithms.   Annals of West University of Timisoara - Mathematics and Computer Science 52,   183–223 (2014). https://doi.org/10.2478/awutm-2014-0019.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.NotImplementedError","page":"Private API","title":"SDiagonalizability.NotImplementedError","text":"NotImplementedError{Nothing}(f, subtype, abstracttype)\nNotImplementedError{Symbol}(f, arg, subtype, abstracttype)\n\nAn exception indicating that a function lacks dispatch to handle a specific argument type.\n\nSemantically, this differs from MethodError in that it connotes a developer-side failure to implement a method rather than erroneous user input. Throughout this package, it is often used to warn when an existing function with multiple dispatch on some abstract type is called on a newly created subtype for which no method has been defined.\n\nFields\n\nf::Function: the function called.\narg::Symbol: the name of the argument with the unsupported type, if the function has   multiple arguments. If the function has only one argument, this field should be set to   nothing.\nsubtype::Type: the type of the argument. May be the actual concrete type or some   intermediate supertype. (For instance, if the relevant input has concrete type A with   hierarchy A <: B <: C and the abstracttype field is C, then both A and B are   perfectly valid choices for subtype.)\nabstracttype::Type: the abstract type under which the argument is meant to fall.\n\nSupertype Hierarchy\n\nNotImplementedError <: Exception\n\nConstructors\n\nNotImplementedError(::Function, ::Type, ::Type): constructs a new NotImplementedError   instance for a single-argument function. Throws an error if the second type is not   abstract or the first type is not a subtype of the second.\nNotImplementedError(::Function, ::Symbol, ::Type, ::Type): constructs a new   NotImplementedError instance for a multi-argument function. Throws an error if the   second type is not abstract or the first type is not a subtype of the second.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.NullGraphLaplacian","page":"Private API","title":"SDiagonalizability.NullGraphLaplacian","text":"NullGraphLaplacian <: ClassifiedLaplacian\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nNullGraphLaplacian <: ClassifiedLaplacian\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.Orthogonality","page":"Private API","title":"SDiagonalizability.Orthogonality","text":"Orthogonality <: KOrthogonality\n\nThe property of pairwise orthogonality for a collection of vectors.\n\nRecall that a collection of vectors v₁ v₂  vₙ is said to be pairwise orthogonal if we have the inner product vᵢ vⱼ = 0 whenever i - j  1 (i.e., if every pair of vectors is orthogonal). This is equivalent to the vectors' Gram matrix being diagonal.\n\nFields\n\nk::Int: the k-orthogonality parameter; always necessarily 1.\n\nSupertype Hierarchy\n\nOrthogonality <: KOrthogonality\n\nConstructors\n\nOrthogonality(): constructs a new Orthogonality object with k = 1.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.QuasiOrthogonality","page":"Private API","title":"SDiagonalizability.QuasiOrthogonality","text":"QuasiOrthogonality <: KOrthogonality\n\nThe property of quasi-orthogonality for a collection of vectors.\n\nRecall that an (ordered) collection of vectors v₁ v₂  vₙ is said to be quasi-orthogonal if we have the inner product vᵢ vⱼ = 0 whenever i - j  2 (i.e., if every pair of vectors at least 2 indices apart is orthogonal). This is equivalent to the vectors' Gram matrix being tridiagonal [JP25, p. 313].\n\nFields\n\nk::Int: the k-orthogonality parameter; always necessarily 2.\n\nSupertype Hierarchy\n\nQuasiOrthogonality <: KOrthogonality\n\nConstructors\n\nQuasiOrthogonality(): constructs a new QuasiOrthogonality object with k = 2.\n\nReferences\n\n[JP25]: N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable   graphs. Linear Algebra and its Applications 704, 309–39 (2025).   https://doi.org/10.1016/j.laa.2024.10.016.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SBandMinimizationResult","page":"Private API","title":"SDiagonalizability.SBandMinimizationResult","text":"SBandMinimizationResult{A,B,C,D} <: AbstractSDiagResult\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nSBandMinimizationResult <: AbstractSDiagResult\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SBandRecognitionResult","page":"Private API","title":"SDiagonalizability.SBandRecognitionResult","text":"SBandRecognitionResult{A,B,C} <: AbstractSDiagResult\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nSBandRecognitionResult <: AbstractSDiagResult\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SDiagonalizabilityResult","page":"Private API","title":"SDiagonalizability.SDiagonalizabilityResult","text":"SDiagonalizabilityResult{A,B,C} <: AbstractSDiagResult\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nSDiagonalizabilityResult <: AbstractSDiagResult\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SSpectra","page":"Private API","title":"SDiagonalizability.SSpectra","text":"SSpectra{A,B,C,D,E}\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SpectrumIntegralResult","page":"Private API","title":"SDiagonalizability.SpectrumIntegralResult","text":"struct SpectrumIntegralResult\n\nData on whether a matrix is spectrum integral (i.e., whether its eigenvalues are integers).\n\nThis struct also contains a map from each eigenvalue to its multiplicity, provided that the eigenvalues are indeed all integers. (Otherwise, the associated field is simply nothing.)\n\nFields\n\nmatrix::Matrix{Int}: the matrix whose eigenvalues and their integrality are of interest.\nspectrum_integral::Bool: whether the eigenvalues of matrix are all integers.\nmultiplicities::Union{Nothing,OrderedDict{Int,Int}}: a map from each eigenvalue to its   multiplicity, sorted first by ascending multiplicity then by ascending eigenvalue. (This   field is nothing if and only if spectrum_integral is false, since we cannot map   non-integer eigenvalues to data.)\n\nNotes\n\nIf an undirected graph with integer edge weights is -1 0 1-diagonalizable (or, more restrictively, -1 1-diagonalizable), then its Laplacian matrix has integer eigenvalues [JP25, p. 312]. Hence, validating Laplacian integrality serves as a useful screening step in this package's principal S-bandwidth minimization algorithm.\n\nReferences\n\n[JP25]: N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable   graphs. Linear Algebra and its Applications 704, 309–39 (2025).   https://doi.org/10.1016/j.laa.2024.10.016.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.WeakOrthogonality","page":"Private API","title":"SDiagonalizability.WeakOrthogonality","text":"WeakOrthogonality <: KOrthogonality\n\nThe property of \"weak orthogonality\" for a collection of vectors.\n\nIn particular, \"weak orthogonality\" is an ad hoc term used to refer to the property of k-orthogonality for k  2. Recall that an (ordered) collection of vectors v₁ v₂  vₙ is said to be k-orthogonal if we have the inner product vᵢ vⱼ = 0 whenever i - j  k (i.e., if every pair of vectors at least k indices apart is orthogonal). This is equivalent to the vectors' Gram matrix having bandwidth at most k.\n\nFields\n\nk::Int: the k-orthogonality parameter. Must be greater than 2.\n\nSupertype Hierarchy\n\nWeakOrthogonality <: KOrthogonality\n\nNotes\n\nThe term \"weak orthogonality\" is not standard terminology in the literature, but it is used here to emphasize the weaker nature of this property compared to orthogonality and quasi-orthogonality. It is an ad hoc term coined for this module and is not intended to be formally introduced in the broader literature.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability._QOBasisSearchNode","page":"Private API","title":"SDiagonalizability._QOBasisSearchNode","text":"_QOBasisSearchNode\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#LinearAlgebra.rank","page":"Private API","title":"LinearAlgebra.rank","text":"rank(A::QRPivoted{<:Any, T}; atol::Real=0, rtol::Real=min(n,m)*ϵ) where {T}\n\nCompute the numerical rank of the QR factorization A by counting how many diagonal entries of A.factors are greater than max(atol, rtol*Δ₁) where Δ₁ is the largest calculated such entry. This is similar to the rank(::AbstractMatrix) method insofar as it counts the number of (numerically) nonzero coefficients from a matrix factorization, although the default method uses an SVD instead of a QR factorization. Like rank(::SVD), this method also re-uses an existing matrix factorization.\n\nComputing rank via QR factorization should almost always produce the same results as via SVD, although this method may be more prone to overestimating the rank in pathological cases where the matrix is ill-conditioned. It is also worth noting that it is generally faster to compute a QR factorization than an SVD, so this method may be preferred when performance is a concern.\n\natol and rtol are the absolute and relative tolerances, respectively. The default relative tolerance is n*ϵ, where n is the size of the smallest dimension of A and ϵ is the eps of the element type of A.\n\nnote: Note\nWhen accessed directly via LinearAlgebra, the rank(::QRPivoted) method requires at least Julia 1.12, so SDiagonalizability defines this method manually for compatibility with v1.10–1.11.\n\n\n\n\n\n","category":"function"},{"location":"private_api/#SDiagonalizability._assert_graph_has_defined_s_bandwidth-Tuple{Graphs.AbstractGraph}","page":"Private API","title":"SDiagonalizability._assert_graph_has_defined_s_bandwidth","text":"_assert_graph_has_defined_s_bandwidth(g) -> Nothing\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._assert_matrix_is_undirected_laplacian-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability._assert_matrix_is_undirected_laplacian","text":"_assert_matrix_is_undirected_laplacian(L) -> Nothing\n\nValidate that L is the Laplacian matrix of an undirected, possibly weighted graph.\n\nArguments\n\nL::AbstractMatrix{<:Integer}: the purported Laplacian matrix.\n\nReturns\n\nnothing: if the check is passed, no output is produced.\n\nThrows\n\nDomainError: if L is not symmetric or has nonzero row sums.\n\nExamples\n\nThe Laplacian matrix of the (undirected) star graph on 5 vertices passes the check:\n\njulia> L = [ 4  -1  -1  -1  -1;\n            -1   1   0   0   0;\n            -1   0   1   0   0;\n            -1   0   0   1   0;\n            -1   0   0   0   1]\n5×5 Matrix{Int64}:\n  4  -1  -1  -1  -1\n -1   1   0   0   0\n -1   0   1   0   0\n -1   0   0   1   0\n -1   0   0   0   1\n\njulia> isnothing(SDiagonalizability._assert_matrix_is_undirected_laplacian(L))\ntrue\n\nThe adjacency matrix of the (undirected) cycle graph on 4 vertices is symmetric but has nonzero row sums, so it fails the check:\n\njulia> A = [0  1  0  1;\n            1  0  1  0;\n            0  1  0  1;\n            1  0  1  0]\n4×4 Matrix{Int64}:\n 0  1  0  1\n 1  0  1  0\n 0  1  0  1\n 1  0  1  0\n\njulia> SDiagonalizability._assert_matrix_is_undirected_laplacian(A)\nERROR: DomainError with [0 1 0 1; 1 0 1 0; 0 1 0 1; 1 0 1 0]:\nMatrix has nonzero row sums; cannot be an (undirected) Laplacian\n[...]\n\nBoth the in-degree and out-degree Laplacian matrices of this random tournament digraph have zero row sums but are not symmetric, so they fail the check. (These are the two standard ways of extending the concept of the Laplacian to directed graphs [VL20, p. 196].)\n\njulia> using Graphs\n\njulia> G = random_tournament_digraph(3; seed=87)\n{3, 3} directed simple Int64 graph\n\njulia> L_in = laplacian_matrix(G; dir=:in)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n  ⋅  ⋅   ⋅\n -1  2  -1\n -1  ⋅   1\n\njulia> SDiagonalizability._assert_matrix_is_undirected_laplacian(L_in)\nERROR: DomainError with sparse([2, 3, 2, 2, 3], [1, 1, 2, 3, 3], [-1, -1, 2, -1, 1], 3, 3):\nMatrix is not symmetric; cannot be an (undirected) Laplacian\n[...]\n\njulia> L_out = laplacian_matrix(G; dir=:out)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n 2  -1  -1\n ⋅   ⋅   ⋅\n ⋅  -1   1\n\njulia> SDiagonalizability._assert_matrix_is_undirected_laplacian(L_out)\nERROR: DomainError with sparse([1, 1, 3, 1, 3], [1, 2, 2, 3, 3], [2, -1, -1, -1, 1], 3, 3):\nMatrix is not symmetric; cannot be an (undirected) Laplacian\n[...]\n\nNotes\n\nIf edges are to be bidirectional, then L must be symmetric. L must also have zero row sums, since the (i i)-th entry is the weighted degree of node i (the sum of all incident edges' weights) and the (i j)-th entry for i  j is the negation of the weight of edge (i j) (or simply 0, if no such edge exists).\n\nGiven the highly optimized, lazy, zero-allocation implementation of LinearAlgebra.issymmetric, the symmetry check is performed first. (Both steps are O(n²) in the worst case, but testing for symmetry is far more performant in practice.) This also allows us to (also lazily) check for nonzero column sums rather than nonzero row sums (since these are equivalent for symmetric matrices) in the second step, taking advantage of Julia's column-major storage model.\n\nAt first blush, it may seem as though the choice of DomainError over something like ArgumentError (or even simply the return of a boolean) constitutes poor design. However, this is informed by the simple ad hoc use of this function to validate inputs for other functions requiring Laplacian matrices. Certainly, this function is never meant to be publicly exposed on its own.\n\nReferences\n\n[VL20]: J. J. Veerman and R. Lyons. A Primer on Laplacian Dynamics in Directed   Graphs. Nonlinear Phenomena in Complex Systems 23, 196–206 (2020).   https://doi.org/10.33581/1561-4085-2020-23-2-196-206.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._classified_laplacian_01neg_spectra-Tuple{T} where T<:SDiagonalizability.ClassifiedLaplacian","page":"Private API","title":"SDiagonalizability._classified_laplacian_01neg_spectra","text":"_classified_laplacian_01neg_spectra(CL) -> SSpectra\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._classified_laplacian_1neg_spectra-Tuple{T} where T<:SDiagonalizability.ClassifiedLaplacian","page":"Private API","title":"SDiagonalizability._classified_laplacian_1neg_spectra","text":"_classified_laplacian_1neg_spectra(CL) -> SSpectra\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._classified_laplacian_s_spectra-Tuple{SDiagonalizability.ArbitraryGraphLaplacian, Tuple{Vararg{Integer}}}","page":"Private API","title":"SDiagonalizability._classified_laplacian_s_spectra","text":"_classified_laplacian_s_spectra(CL, S) -> SSpectra\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._extract_independent_cols-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability._extract_independent_cols","text":"_extract_independent_cols(A) -> Matrix{Int}\n\nReturn a (not necessarily unique) independent spanning subset of the columns of A.\n\nComputing a rank-revealing (pivoted) QR decomposition of A, the scaling coefficients from the orthogonalization process are used to determine the rank (rather than recompute it with an SVD), while the pivots are used to extract a spanning set of independent columns.\n\nThe rank-revealing Businger–Golub QR algorithm is used for the pivoting strategy, appending the \"most independent\" column with respect to the current set of pivots at each step via Householder transformations [BG65, pp. 269–70].\n\nArguments\n\nA::AbstractMatrix{T<:Integer}: the matrix whose independent columns to extract.\n\nReturns\n\n::Matrix{Int}: a spanning set of independent columns of A.\n\nExamples\n\nObserve how columns with greater Euclidean norms are given priority in the pivot ordering:\n\njulia> A = [3  0  0  0  2  1   5   0\n            0  3  0  0  2  1  -5   0\n            0  0  3  0  2  1   5   4\n            0  0  0  3  2  1   0  -4\n            0  0  0  0  0  0   0   0]\n5×8 Matrix{Int64}:\n 3  0  0  0  2  1   5   0\n 0  3  0  0  2  1  -5   0\n 0  0  3  0  2  1   5   4\n 0  0  0  3  2  1   0  -4\n 0  0  0  0  0  0   0   0\n\njulia> SDiagonalizability._extract_independent_cols(A)\n5×4 Matrix{Int64}:\n  5   0  2  3\n -5   0  2  0\n  5   4  2  0\n  0  -4  2  0\n  0   0  0  0\n\nNotes\n\nSince we already need a pivoted QR decomposition to identify independent columns of A (or, rather, to order the columns in such a way that the first rank(A) ones are guaranteed to be independent), it makes sense to use data from the resulting factorization object to compute the rank of A rather than compute a separate SVD. We thus count the nonzero scaling coefficients—that is, the diagonal entries of the R matrix in A = QR—to determine the rank, similarly to how we count the nonzero singular values in an SVD.\n\nIt is worth noting that we manually specify a higher relative tolerance for this rank computation. Further discussion can be found in the _rank_rtol documentation, but in short, a critical part of the formula for LinearAlgebra.rank's default rtol uses the minimum dimension of the input matrix. This may result in rank overestimation for tall-and-skinny and short-and-fat matrices (precisely the type we expect to encounter when dealing with all -1 0 1-eigenvectors of a Laplacian matrix, which is the intended use case of this helper function in this package). Our replacement tolerance, on the other hand, is a widely accepted standard in numerical analysis which uses the maximum dimension instead [PTVF07, p. 795].\n\nReferences\n\n[BG65]: P. Businger and G. H. Golub. Linear Least Squares Solutions by Householder   Transformations. Numerische Mathematik 7, 269–76 (1965).   https://doi.org/10.1007/BF01436084.\n[PTVF07]: W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery.   Numerical Recipes: The Art of Scientific Computing. 3rd Edition (Cambridge University   Press, Cambridge, UK, 2007). ISBN: 978-0-521-88068-8.   https://dl.acm.org/doi/10.5555/1403886.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._find_basis_idxs_with_prop-Union{Tuple{K}, Tuple{AbstractVector{Int64}, K, AbstractMatrix{Int64}, Integer, Int64, Vararg{Any}}} where K<:SDiagonalizability.KOrthogonality","page":"Private API","title":"SDiagonalizability._find_basis_idxs_with_prop","text":"_find_basis_idxs_with_prop(\n    curr_idxs, prop::Orthogonality, col_space, col_rank, depth\n) -> Union{Nothing,AbstractVector{Int}}\n_find_basis_idxs_with_prop(\n    curr_idxs, prop::QuasiOrthogonality, col_space, col_rank, depth, nodes, union_find\n) -> Union{Nothing,AbstractVector{Int}}\n_find_basis_idxs_with_prop(\n    curr_idxs, prop::WeakOrthogonality, col_space, col_rank, depth, gram_matrix\n) -> Union{Nothing,AbstractVector{Int}}\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._find_basis_with_property-Union{Tuple{K}, Tuple{AbstractMatrix{<:Integer}, Integer, K}} where K<:SDiagonalizability.KOrthogonality","page":"Private API","title":"SDiagonalizability._find_basis_with_property","text":"_find_basis_with_property(col_space::T, col_rank, prop) -> Union{Nothing,T}\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._laplacian_01neg_spectra-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability._laplacian_01neg_spectra","text":"_laplacian_01neg_spectra(L) -> SSpectra\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._laplacian_1neg_spectra-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability._laplacian_1neg_spectra","text":"_laplacian_1neg_spectra(L) -> SSpectra\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_kernel_01neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_kernel_01neg_eigvecs","text":"_pot_kernel_01neg_eigvecs(n) -> Iterators.Flatten{<:Base.Generator}\n\nLazily compute all potential kernel -1 0 1-eigenvectors of an nn Laplacian.\n\nEach vector is normalized so that its first nonzero entry is 1, enforcing pairwise linear independence between all generated vectors.\n\nArguments\n\nn::Integer: the order of the Laplacian matrix of some undirected graph for which to find   potential kernel eigenvectors.\n\nReturns\n\neigvec_generator::Iterators.Flatten{<:Base.Generator}: a lazily evaluated iterator over   all -1 0 1-vectors in ℝⁿ, unique up to span.\n\nExamples\n\nGenerate all potential kernel eigenvectors for an order 3 Laplacian matrix:\n\njulia> hcat(SDiagonalizability._pot_kernel_01neg_eigvecs(3)...)\n3×13 Matrix{Int64}:\n  1   1   1   1  1  1   1  1  1   0  0  0  0\n -1  -1  -1   0  0  0   1  1  1   1  1  1  0\n -1   0   1  -1  0  1  -1  0  1  -1  0  1  1\n\nNotes\n\nThe number of potential kernel eigenvectors (unique up to span) for an order n Laplacian matrix is given by (3ⁿ - 1)  2. See also the relevant OEIS sequence [Slo25].\n\nRegrettably, the implementation here is rather clunky and unidiomatic, but it is worth noting that eigenvector generation is one of two major bottlenecks in the overall S-bandwidth minimization algorithm. Given how much potential there is for optimization in this piece of code, we thus prioritize performance over readability in this particular case, making every effort to include inline comments wherever clarification may be needed.\n\nReferences\n\n[Slo25]: N. J. Sloane, a(n) = (3^n - 1)/2. Entry A003462 (2025). Accessed:   2025-05-22. https://oeis.org/A003462.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_kernel_1neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_kernel_1neg_eigvecs","text":"_pot_kernel_1neg_eigvecs(n) -> Iterators.Flatten{<:Base.Generator}\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_nonkernel_01neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_nonkernel_01neg_eigvecs","text":"_pot_nonkernel_01neg_eigvecs(n) -> Iterators.Flatten{<:Base.Generator}\n\nLazily compute all potential non-kernel -1 0 1-eigenvectors of an nn Laplacian.\n\nEach vector is normalized so that its first nonzero entry is 1, enforcing pairwise linear independence between all generated vectors. Since all Laplacian matrices have pairwise orthogonal eigenspaces and the all-ones vector is always in the kernel, every non-kernel -1 0 1-eigenvector must also have an equal number of -1's and 1's.\n\nArguments\n\nn::Integer: the order of the Laplacian matrix of some undirected graph for which to find   potential non-kernel eigenvectors.\n\nReturns\n\neigvec_generator::Iterators.Flatten{<:Base.Generator}: a lazily evaluated iterator over   all -1 0 1-vectors in ℝⁿ orthogonal to the all-ones kernel vector,   unique up to span.\n\nExamples\n\nGenerate all potential non-kernel eigenvectors of an order 4 Laplacian matrix:\n\njulia> hcat(SDiagonalizability._pot_nonkernel_01neg_eigvecs(4)...)\n4×9 Matrix{Int64}:\n  1   1   1   1   1   1   0   0   0\n -1   0   0  -1  -1   1   1   1   0\n  0  -1   0  -1   1  -1  -1   0   1\n  0   0  -1   1  -1  -1   0  -1  -1\n\nNotes\n\nThe number of potential non-kernel eigenvectors (unique up to span) for an order n Laplacian matrix is, by non-trivial combinatorial arguments, equal to the number of humps in all Motzkin paths of length n. See also the relevant OEIS sequence [Deu25].\n\nRegrettably, the implementation here is rather clunky and unidiomatic, but it is worth noting that eigenvector generation is one of two major bottlenecks in the overall S-bandwidth minimization algorithm. Given how much potential there is for optimization in this piece of code, we thus prioritize performance over readability in this particular case, making every effort to include inline comments wherever clarification may be needed.\n\nReferences\n\n[Deu25]: E. Deutsch. Number of humps in all Motzkin paths of length n. Entry   A097861 (2025). Accessed: 2025-05-22. https://oeis.org/A097861.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_nonkernel_1neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_nonkernel_1neg_eigvecs","text":"_pot_nonkernel_1neg_eigvecs(n)\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._rank_rtol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Private API","title":"SDiagonalizability._rank_rtol","text":"function _rank_rtol(A::AbstractMatrix{<:Real}) -> Float64\n\nReturn a reasonable relative tolerance for computing matrix rank via SVD or QRD.\n\nThe output is intended to be passed as a keyword argument to LinearAlgebra.rank. LinearAlgebra.eigtype is used to determine the appropriate machine epsilon for the element type of A when eltype(A) is not an AbstractFloat.\n\nArguments\n\nA::AbstractMatrix{<:Real}: the matrix for which to compute a tolerance.\n\nReturns\n\ntol::Float64: a reasonable relative tolerance for computing matrix rank via SVD or QRD.   This scales proportionally to the maximum dimension of A.\n\nNotes\n\nLinearAlgebra.rank's default rtol of min(m,n) * ϵ for computing the rank of an mn matrix may result in overestimating rank when m - n  0, since condition number (which determines how numerically stable SVD and QRD are) grows with both dimensions [CD05, p. 603]. Given that we often deal with short-and-fat matrices in this package (particularly when processing all -1 0 1-eigenvectors of a Laplacian matrix), we turn instead to the same relative tolerance used by MATLAB's and NumPy's rank functions—max(m,n) * ϵ [MAT25; Num25]. (Indeed, this is a widely adopted standard across the field of numerical analysis [PTVF07, p. 795].)\n\nReferences\n\n[CD05]: Z. Chen and J. Dongarra. Condition Numbers of Gaussian Random Matrices.   SIAM Journal on Matrix Analysis and Applications 27, 603–20 (2005).   https://doi.org/10.1137/040616413.\n[MAT25]: MATLAB Developers, rank. MATLAB reference documentation – R2025a (2025).   Accessed: 2025-05-29. https://www.mathworks.com/help/matlab/ref/rank.html.\n[Num25]: NumPy Developers, numpy.linalg.matrix_rank. NumPy reference   documentation – v2.2 (2025). Accessed: 2025-05-22.   https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_rank.html.\n[PTVF07]: W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery.   Numerical Recipes: The Art of Scientific Computing. 3rd Edition (Cambridge University   Press, Cambridge, UK, 2007). ISBN: 978-0-521-88068-8.   https://dl.acm.org/doi/10.5555/1403886.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._sort_tuple-Tuple{Tuple{Vararg{Integer}}}","page":"Private API","title":"SDiagonalizability._sort_tuple","text":"_sort_tuple(S::T) where {T<:Tuple{Vararg{Integer}}} -> T\n\nReturn a sorted version of the input tuple.\n\nArguments\n\nS::T<:Tuple{Vararg{Integer}}: the tuple to sort.\n\nReturns\n\n::T: a sorted version of S.\n\nExamples\n\njulia> S = (-1, 1, 0)\n(-1, 1, 0)\n\njulia> SDiagonalizability._sort_tuple(S)\n(-1, 0, 1)\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.check_spectrum_integrality-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability.check_spectrum_integrality","text":"check_spectrum_integrality(A) -> SpectrumIntegralResult\n\nCheck whether the eigenvalues of A are integers (up to floating-point error).\n\nIf the eigenvalues are indeed all integers, then an eigenvalue-multiplicity map is constructed as well.\n\nArguments\n\nA::AbstractMatrix{<:Integer}: the matrix whose eigenvalues to check for integrality.\n\nReturns\n\n::SpectrumIntegralResult: a struct containing the following fields:\nmatrix: the A matrix, copied to avoid shared mutability.\nspectrum_integral: whether the eigenvalues of A are integers.\nmultiplicities: a map from each eigenvalue to its multiplicity, sorted first by   ascending multiplicity then by ascending eigenvalue. (This field is nothing if the   eigenvalues are not all integers.)\n\nExamples\n\nConfirm that the rotation matrix by π2 radians counterclockwise is not spectrum integral (rather, it has eigenvalues i [Joy15, p. 1]):\n\njulia> R = Int8.([0 -1; 1 0])\n2×2 Matrix{Int8}:\n 0  -1\n 1   0\n\njulia> res = SDiagonalizability.check_spectrum_integrality(R);\n\njulia> res.matrix\n2×2 Matrix{Int64}:\n 0  -1\n 1   0\n\njulia> res.spectrum_integral\nfalse\n\njulia> isnothing(res.multiplicities)\ntrue\n\nConfirm that the adjacency matrix of the Petersen graph is spectrum integral, with correct eigenvalues and multiplicities of 3 1 -2 4 1 5 [Fox09, p. 2]:\n\njulia> using Graphs\n\njulia> G = smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\njulia> A = adjacency_matrix(G)\n10×10 SparseArrays.SparseMatrixCSC{Int64, Int64} with 30 stored entries:\n ⋅  1  ⋅  ⋅  1  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅\n 1  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  1\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  1  ⋅  ⋅  1  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅\n\njulia> res = SDiagonalizability.check_spectrum_integrality(A);\n\njulia> res.matrix\n10×10 Matrix{Int64}:\n 0  1  0  0  1  1  0  0  0  0\n 1  0  1  0  0  0  1  0  0  0\n 0  1  0  1  0  0  0  1  0  0\n 0  0  1  0  1  0  0  0  1  0\n 1  0  0  1  0  0  0  0  0  1\n 1  0  0  0  0  0  0  1  1  0\n 0  1  0  0  0  0  0  0  1  1\n 0  0  1  0  0  1  0  0  0  1\n 0  0  0  1  0  1  1  0  0  0\n 0  0  0  0  1  0  1  1  0  0\n\njulia> res.spectrum_integral\ntrue\n\njulia> res.multiplicities\nOrderedCollections.OrderedDict{Int64, Int64} with 3 entries:\n  3  => 1\n  -2 => 4\n  1  => 5\n\nNotes\n\nIf an undirected graph with integer edge weights is -1 0 1-diagonalizable (or, more restrictively, -1 1-diagonalizable), then its Laplacian matrix has integer eigenvalues [JP25, p. 312]. Hence, validating Laplacian integrality serves as a useful screening step in this package's principal S-bandwidth minimization algorithm.\n\nReferences\n\n[Fox09]: J. Fox. Lecture 19: The Petersen graph and Moore graphs. Lecture notes,   MAT 307: Combinatorics (2009). Accessed: 2025-07-25.   https://math.mit.edu/~fox/MAT307.html.\n[Joy15]: D. Joyce. Rotations and complex eigenvalues. Lecture notes, Math 130:   Linear Algebra (2015). http://aleph0.clarku.edu/~ma130/complexeigen.pdf.\n[JP25]: N. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable   graphs. Linear Algebra and its Applications 704, 309–39 (2025).   https://doi.org/10.1016/j.laa.2024.10.016.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.classify_k_orthogonality-Tuple{Integer}","page":"Private API","title":"SDiagonalizability.classify_k_orthogonality","text":"classify_k_orthogonality(k)\n\nClassifies the k-orthogonality property based on the given k parameter.\n\nWhen searching for a k-orthogonal S-basis of a given Laplacian eigenspace, the family of values to which our k parameter belongs informs our choice of algorithm.\n\nArguments\n\nk::Integer: the k-orthogonality parameter to classify. Must be a positive integer.\n\nReturns\n\n::KOrthogonality: An instance of a concrete KOrthogonality subtype   corresponding to k.\n\nThrows\n\nDomainError: if k is not a positive integer.\n\nExamples\n\njulia> SDiagonalizability.classify_k_orthogonality(1)\nSDiagonalizability.Orthogonality(1)\n\njulia> SDiagonalizability.classify_k_orthogonality(2)\nSDiagonalizability.QuasiOrthogonality(2)\n\njulia> SDiagonalizability.classify_k_orthogonality(3)\nSDiagonalizability.WeakOrthogonality(3)\n\njulia> SDiagonalizability.classify_k_orthogonality(13)\nSDiagonalizability.WeakOrthogonality(13)\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.classify_laplacian-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability.classify_laplacian","text":"classify_laplacian(L)\n\nClassify the Laplacian matrix L and wrap it in a ClassifiedLaplacian object.\n\nIt is first verified that L is indeed a Laplacian matrix by _assert_matrix_is_undirected_laplacian, which throws a DomainError otherwise. It is then classified based on any properties which may be exploited in computing data on its \\{-1, 0, 1\\}-spectrum.\n\nArguments\n\nL::AbstractMatrix{<:Integer}: the Laplacian matrix to classify.\n\nReturns\n\nCL::ClassifiedLaplacian: the Laplacian wrapped in a concrete   ClassifiedLaplacian subtype associated with the category of the   graph represented by L. In the case of complete graphs, CL also contains data on the   (necessarily uniform) weight of each edge.\n\nExamples\n\nCorrectly recognizes the Laplacian matrix of the null graph:\n\njulia> using Graphs\n\njulia> G = Graph(0)\n{0, 0} undirected simple Int64 graph\n\njulia> L = laplacian_matrix(G)\n0×0 SparseArrays.SparseMatrixCSC{Int64, Int64} with 0 stored entries\n\njulia> SDiagonalizability.classify_laplacian(L)\nSDiagonalizability.NullGraphLaplacian(Matrix{Int64}(undef, 0, 0))\n\nCorrectly recognizes the Laplacian matrix of the empty graph on 3 nodes:\n\njulia> using Graphs\n\njulia> G = Graph(3)\n{3, 0} undirected simple Int64 graph\n\njulia> L = laplacian_matrix(G)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 0 stored entries:\n ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅\n\njulia> SDiagonalizability.classify_laplacian(L)\nSDiagonalizability.EmptyGraphLaplacian([0 0 0; 0 0 0; 0 0 0])\n\nCorrectly recognizes the Laplacian matrix of the complete graph on 4 nodes:\n\njulia> using Graphs\n\njulia> G = complete_graph(4)\n{4, 6} undirected simple Int64 graph\n\njulia> L = laplacian_matrix(G)\n4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 16 stored entries:\n  3  -1  -1  -1\n -1   3  -1  -1\n -1  -1   3  -1\n -1  -1  -1   3\n\njulia> SDiagonalizability.classify_laplacian(L)\nSDiagonalizability.CompleteGraphLaplacian([3 -1 -1 -1; -1 3 -1 -1; -1 -1 3 -1; -1 -1 -1 3], 1)\n\nCorrectly recognizes the Laplacian matrix of this random generic graph:\n\njulia> using Graphs\n\njulia> G = erdos_renyi(5, 8; seed=87)\n{5, 8} undirected simple Int64 graph\n\njulia> L = laplacian_matrix(G)\n5×5 SparseArrays.SparseMatrixCSC{Int64, Int64} with 21 stored entries:\n  3   ⋅  -1  -1  -1\n  ⋅   2  -1  -1   ⋅\n -1  -1   4  -1  -1\n -1  -1  -1   4  -1\n -1   ⋅  -1  -1   3\n\njulia> SDiagonalizability.classify_laplacian(L)\nSDiagonalizability.ArbitraryGraphLaplacian([3 0 … -1 -1; 0 2 … -1 0; … ; -1 -1 … 4 -1; -1 0 … -1 3])\n\nNotes\n\nRight now, the possible types of Laplacian matrices (or, to be more precise, the graphs they represent) are:\n\nNullGraphLaplacian: the (unique) graph with no nodes.\nEmptyGraphLaplacian: any graph with no edges on n  1 nodes.\nCompleteGraphLaplacian: any graph on n  2 nodes where every pair of nodes is   connected by an edge and all edges possess the same weight.\nArbitraryGraphLaplacian: any graph on n  3 nodes with no particular   strcuture of relevance in the context of investigating -1 0 1-spectra.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.find_k_orthogonal_basis","page":"Private API","title":"SDiagonalizability.find_k_orthogonal_basis","text":"find_k_orthogonal_basis(\n    col_space, col_rank, k, pre_basis=nothing\n) -> Union{Nothing,AbstractMatrix{<:Integer}}\n\nFind a k-orthogonal spanning subset of the column set of a matrix.\n\nThis function does not allow for any k-orthogonal basis of col_space (in which case it would be trivial to construct a pairwise orthogonal basis via a QR decomposition). Instead, it restricts its search to spanning subsets comprised exclusively of columns already in col_space, returning nothing if no such basis exists.\n\nArguments\n\ncol_space::T<:AbstractMatrix{<:Integer}: the matrix whose column space is searched for a   k-orthogonal basis.\ncol_rank::Integer: the rank of the column space of col_space, pre-computed for   efficiency.\nk::Integer: the minimum k-orthogonality parameter of the desired basis. Must be a   positive integer.\npre_basis::Union{Nothing,AbstractMatrix{<:Integer}}=nothing: an optional precomputed   submatrix of col_space whose columns form a spanning subset of the column space of   col_space. In case col_space has at most k columns, existing_basis is guaranteed   to already be a k-orthogonal basis and thus is used to skip unnecessary computations.\n\nReturns\n\n::Union{Nothing,AbstractMatrix{<:Integer}}: a k-orthogonal spanning subset of the   columns of col_space, if one exists; otherwise, nothing.\n\n\n\n\n\n","category":"function"},{"location":"private_api/#SDiagonalizability.laplacian_s_spectra-Tuple{AbstractMatrix{<:Integer}, Tuple{Vararg{Integer}}}","page":"Private API","title":"SDiagonalizability.laplacian_s_spectra","text":"laplacian_s_spectra(L, S) -> SSpectra\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.pot_kernel_s_eigvecs-Tuple{Integer, Tuple{Vararg{Integer}}}","page":"Private API","title":"SDiagonalizability.pot_kernel_s_eigvecs","text":"pot_kernel_s_eigvecs(n, S) -> Iterators.Flatten{<:Base.Generator}\n\n[TODO: Write here]\n\nArguments\n\n[TODO: Write here]\n\nReturns\n\n[TODO: Write here]\n\nThrows\n\nDomainError: if n is negative.\n\nExamples\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.pot_nonkernel_s_eigvecs-Tuple{Integer, Tuple{Vararg{Integer}}}","page":"Private API","title":"SDiagonalizability.pot_nonkernel_s_eigvecs","text":"pot_nonkernel_s_eigvecs(n, S) -> Iterators.Flatten{<:Base.Generator}\n\n[TODO: Write here]\n\nArguments\n\n[TODO: Write here]\n\nReturns\n\n[TODO: Write here]\n\nThrows\n\nDomainError: if n is negative.\n\nExamples\n\n[TODO: Write here]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#References","page":"Private API","title":"References","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"P. Businger and G. H. Golub. Linear Least Squares Solutions by Householder Transformations. Numerische Mathematik 7, 269–76 (1965).\n\n\n\nZ. Chen and J. Dongarra. Condition Numbers of Gaussian Random Matrices. SIAM Journal on Matrix Analysis and Applications 27, 603–20 (2005).\n\n\n\nE. Deutsch. Number of humps in all Motzkin paths of length n. Entry A097861 (2025). Accessed: 2025-05-22.\n\n\n\nJ. Fox. Lecture 19: The Petersen graph and Moore graphs. Lecture notes, MAT 307: Combinatorics (2009). Accessed: 2025-07-25.\n\n\n\nD. Joyce. Rotations and complex eigenvalues. Lecture notes, Math 130: Linear Algebra (2015).\n\n\n\nL. O. Mafteiu-Scai. The Bandwidths of a Matrix. A Survey of Algorithms. Annals of West University of Timisoara - Mathematics and Computer Science 52, 183–223 (2014).\n\n\n\nW. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery. Numerical Recipes: The Art of Scientific Computing. 3rd Edition (Cambridge University Press, Cambridge, UK, 2007). ISBN: 978-0-521-88068-8.\n\n\n\nN. J. Sloane, a(n) = (3^n - 1)/2. Entry A003462 (2025). Accessed: 2025-05-22.\n\n\n\nJ. J. Veerman and R. Lyons. A Primer on Laplacian Dynamics in Directed Graphs. Nonlinear Phenomena in Complex Systems 23, 196–206 (2020).\n\n\n\nMATLAB Developers, rank. MATLAB reference documentation – R2025a (2025). Accessed: 2025-05-29.\n\n\n\nNumPy Developers, numpy.linalg.matrix_rank. NumPy reference documentation – v2.2 (2025). Accessed: 2025-05-22.\n\n\n\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"<figure style=\"text-align: left; margin-left: 0;\">\n  <img src=\"https://github.com/GraphQuantum/SDiagonalizability.jl/raw/main/docs/src/assets/logo.jpg\" alt=\"GraphQuantum logo by Madiha Waqar\">\n  <figcaption>\n    GraphQuantum<em style=\"font-style: normal;\"> logo by <a href=\"https://github.com/madihaahmed1\">Madiha Waqar</em></a>\n  </figcaption>\n</figure>\n\n<table>\n  <tr>\n    <td>Metadata</td>\n    <td>\n      <img src=\"https://img.shields.io/badge/version-v0.1.1-pink.svg\" alt=\"Version\">\n      <a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/License-MIT-A31F34.svg\" alt=\"License: MIT\"></a>\n      <a href=\"https://github.com/JuliaDiff/BlueStyle\"><img src=\"https://img.shields.io/badge/code%20style-blue-4495d1.svg\" alt=\"Code Style: Blue\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Documentation</td>\n    <td>\n      <a href=\"https://graphquantum.github.io/SDiagonalizability.jl/stable/\"><img src=\"https://img.shields.io/badge/docs-stable-darkgreen.svg\" alt=\"Documentation of latest stable version\"></a>\n      <a href=\"https://graphquantum.github.io/SDiagonalizability.jl/dev/\"><img src=\"https://img.shields.io/badge/docs-dev-rebeccapurple.svg\" alt=\"Documentation of dev version\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Continuous integration</td>\n    <td>\n      <a href=\"https://github.com/GraphQuantum/SDiagonalizability.jl/actions?query=workflow%3ACI+branch%3Amain\"><img src=\"https://github.com/GraphQuantum/SDiagonalizability.jl/actions/workflows/CI.yml/badge.svg\" alt=\"GitHub Workflow Status\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Code coverage</td>\n    <td>\n      <a href=\"https://codecov.io/gh/GraphQuantum/SDiagonalizability.jl\"><img src=\"https://codecov.io/gh/GraphQuantum/SDiagonalizability.jl/branch/main/graph/badge.svg\" alt=\"Test coverage from codecov\"></a>\n    </td>\n    </tr>\n    <tr>\n      <td>Static analysis with</td>\n      <td>\n        <a href=\"https://github.com/JuliaTesting/Aqua.jl\"><img src=\"https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg\" alt=\"Aqua QA\"></a>\n        <a href=\"https://github.com/aviatesk/JET.jl\"><img src=\"https://img.shields.io/badge/%E2%9C%88%20tested%20with-JET.jl%EF%B8%8F-9cf.svg\" alt=\"JET static analysis\"></a>\n      </td>\n    </tr>\n</table>","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SDiagonalizability.jl implements the first non-naïve deterministic algorithm to minimize the S-bandwidth of an undirected graph with integer edge weights. Capabilities also exist for determining whether a graph has S-bandwidth less than or equal to a fixed integer k ge 1 without necessarily caring about the true minimum value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given an undirected, possibly weighted graph G and finite set of integers S subset mathbbZ, G is said to be \"S-diagonalizable\" if there exists some diagonal matrix D and matrix P with all entries from S such that G's Laplacian matrix L(G) = PDP^-1. If G is S-diagonalizable, then its \"S-bandwidth\" is the minimum integer k in 1 2 ldots V(G) such that there exists some diagonal matrix D and matrix P with all entries from S such that L(G) = PDP^-1 and P^mathsfTP_ij = 0 whenever i - j geq k; otherwise, its S-bandwidth is simply infty.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For specific choices of S (namely -1 1 and -1 0 1), the S-bandwidth of a quantum network has been shown to be an indicator of high state transfer fidelity due to automorphic properties of the graph. As such, the nascent study of S-diagonalizability and S-bandwidth is of interest in the broader context of quantum information theory.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The only prerequisite is a working Julia installation (v1.10 or later). First, enter Pkg mode by typing ] in the Julia REPL, then run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SDiagonalizability","category":"page"},{"location":"#Basic-use","page":"Home","title":"Basic use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SDiagonalizability.jl offers capabilities for S-bandwidth minimization, S-bandwidth recognition, and plain old S-diagonalizability checking. To compute the S-bandwidth of a graph, you can use the s_bandwidth function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Graphs\n\njulia> g = complete_graph(14)\n{14, 91} undirected simple Int64 graph\n\njulia> res_01neg = s_bandwidth(g, (-1, 0, 1))\nResults of S-Bandwidth Minimization\n * S: (-1, 0, 1)\n * S-Bandwidth: 2\n * Graph Order: 14\n\njulia> res_01neg.s_diagonalization\nLinearAlgebra.Eigen{Int64, Int64, Matrix{Int64}, Vector{Int64}}\nvalues:\n14-element Vector{Int64}:\n  0\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\nvectors:\n14×14 Matrix{Int64}:\n 1   0   0   0   0   1   1   1   1   1   1   0   0   0\n 1   0   0   0   0  -1   0  -1   1   1   1   0   0   0\n 1   0   0   0   0   0  -1   1   0   1   1   0   0   0\n 1   0   0   0   0   0   0  -1   0   1  -1   0   0   0\n 1   0   0   0   0   0   0   0  -1  -1   1   1   1   1\n 1   0   0   0   0   0   0   0  -1  -1   1  -1  -1  -1\n 1   1   1   0   0   0   0   0   0  -1   0   0  -1   1\n 1  -1  -1   0   0   0   0   0   0  -1   0   0   0  -1\n 1   0  -1   1   1   0   0   0   0   0  -1   0   0   0\n 1   0   0  -1  -1   0   0   0   0   0  -1   0   0   0\n 1   0   0   0  -1   0   0   0   0   0  -1   0   0   0\n 1   0   1   0   1   0   0   0   0   0  -1   0   0   0\n 1  -1  -1   0   0   0   0   0   0   0   0   0   0   1\n 1   1   1   0   0   0   0   0   0   0   0   0   1  -1\n\njulia> res_1neg = s_bandwidth(g, (-1, 1))\nResults of S-Bandwidth Minimization\n * S: (-1, 1)\n * S-Bandwidth: 13\n * Graph Order: 14\n\njulia> res_1neg.s_diagonalization\nLinearAlgebra.Eigen{Int64, Int64, Matrix{Int64}, Vector{Int64}}\nvalues:\n14-element Vector{Int64}:\n  0\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\n 14\nvectors:\n14×14 Matrix{Int64}:\n 1   1   1   1   1   1   1   1   1   1   1   1   1   1\n 1  -1  -1  -1  -1  -1  -1   1   1   1   1   1   1   1\n 1  -1  -1  -1   1   1   1  -1  -1  -1   1   1   1   1\n 1  -1  -1  -1   1   1   1   1   1   1  -1  -1  -1   1\n 1  -1  -1  -1   1   1   1   1   1   1   1   1   1  -1\n 1  -1   1   1  -1  -1   1  -1  -1   1  -1  -1   1  -1\n 1  -1   1   1  -1   1  -1  -1   1  -1  -1   1  -1  -1\n 1  -1   1   1   1  -1  -1   1  -1  -1   1  -1  -1   1\n 1   1  -1   1  -1  -1   1  -1   1  -1   1  -1  -1   1\n 1   1  -1   1  -1   1  -1   1  -1  -1  -1  -1   1  -1\n 1   1  -1   1   1  -1  -1  -1  -1   1  -1   1  -1  -1\n 1   1   1  -1  -1  -1   1   1  -1  -1  -1   1  -1  -1\n 1   1   1  -1  -1   1  -1  -1  -1   1   1  -1  -1   1\n 1   1   1  -1   1  -1  -1  -1   1  -1  -1  -1   1  -1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, to determine whether a graph has S-bandwidth less than or equal to some fixed integer k ge 1 without necessarily caring about the true (minimum) value, you can take advantage of has_s_bandwidth_at_most_k:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Graphs\n\njulia> g = PetersenGraph()\n{10, 15} undirected simple Int64 graph\n\njulia> res_01neg = has_s_bandwidth_at_most_k(g, (-1, 0, 1), 4)\nResults of S-Bandwidth Recognition\n * S: (-1, 0, 1)\n * S-Bandwidth Threshold k: 4\n * Has S-Bandwidth ≤ k: true\n * Graph Order: 10\n\njulia> res_01neg.s_diagonalization\nLinearAlgebra.Eigen{Int64, Int64, Matrix{Int64}, Vector{Int64}}\nvalues:\n10-element Vector{Int64}:\n 0\n 5\n 5\n 5\n 5\n 2\n 2\n 2\n 2\n 2\nvectors:\n10×10 Matrix{Int64}:\n 1   1   1   0   0   1   1   1   1   1\n 1  -1  -1   1   1   0   0   0   0   1\n 1   0   1  -1  -1   0  -1   0  -1  -1\n 1   0   0   0   1   0   0   0  -1  -1\n 1   0  -1   0  -1   1   1   0   0   0\n 1  -1   0  -1   0   0   0   1   1   0\n 1   1   0  -1  -1  -1   0  -1   0   1\n 1   1  -1   1   0   0  -1   0   0  -1\n 1   0   0   1   0  -1   0   0   0   0\n 1  -1   1   0   1   0   0  -1   0   0\n\njulia> res_1neg = has_s_bandwidth_at_most_k(g, (-1, 1), 10)\nResults of S-Bandwidth Recognition\n * S: (-1, 1)\n * S-Bandwidth Threshold k: 10\n * Has S-Bandwidth ≤ k: false\n * Graph Order: 10\n\njulia> isnothing(res_1neg.s_diagonalization)\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lastly, the is_s_diagonalizable function can be used to simply determine whether a graph is S-diagonalizable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Graphs\n\njulia> L = laplacian_matrix(complete_multipartite_graph([1, 1, 2, 2, 3]))\n9×9 SparseArrays.SparseMatrixCSC{Int64, Int64} with 71 stored entries:\n  8  -1  -1  -1  -1  -1  -1  -1  -1\n -1   8  -1  -1  -1  -1  -1  -1  -1\n -1  -1   7   ⋅  -1  -1  -1  -1  -1\n -1  -1   ⋅   7  -1  -1  -1  -1  -1\n -1  -1  -1  -1   7   ⋅  -1  -1  -1\n -1  -1  -1  -1   ⋅   7  -1  -1  -1\n -1  -1  -1  -1  -1  -1   6   ⋅   ⋅\n -1  -1  -1  -1  -1  -1   ⋅   6   ⋅\n -1  -1  -1  -1  -1  -1   ⋅   ⋅   6\n\njulia> res_01neg = is_s_diagonalizable(L, (-1, 0, 1))\nResults of S-Diagonalizability Check\n * S: (-1, 0, 1)\n * S-Diagonalizable: true\n * Graph Order: 9\n\njulia> res_01neg.s_diagonalization\nLinearAlgebra.Eigen{Int64, Int64, Matrix{Int64}, Vector{Int64}}\nvalues:\n9-element Vector{Int64}:\n 0\n 6\n 6\n 7\n 7\n 9\n 9\n 9\n 9\nvectors:\n9×9 Matrix{Int64}:\n 1   0   0   0   0   1   1   1   1\n 1   0   0   0   0   0  -1  -1   1\n 1   0   0   1   1  -1  -1   1  -1\n 1   0   0  -1  -1  -1  -1   1  -1\n 1   0   0  -1   1  -1   1  -1   0\n 1   0   0   1  -1  -1   1  -1   0\n 1   1   1   0   0   1   0   0   0\n 1  -1   0   0   0   1   0   0   0\n 1   0  -1   0   0   1   0   0   0\n\njulia> res_1neg = is_s_diagonalizable(L, (-1, 1))\nResults of S-Diagonalizability Check\n * S: (-1, 1)\n * S-Diagonalizable: false\n * Graph Order: 9\n\njulia> isnothing(res_1neg.s_diagonalization)\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"(As demonstrated in this last example, you can supply the Laplacian matrix of a graph as an alternative to the Graph object itself from the Graphs.jl package.)","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The full documentation is available at GitHub Pages. Documentation for methods and types is also available via the Julia REPL. (Note that as we have just completed development of the core API, many symbols lack complete documentation at this time—we aim to rectify this by the release of v0.2.0.)","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We encourage you to cite our work if you have used our algorithm in your research. Starring the SDiagonalizability.jl repository on GitHub is also appreciated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latest citation information may be found in the CITATION.bib file within the repository.","category":"page"},{"location":"#Project-status","page":"Home","title":"Project status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable release of SDiagonalizability.jl is v0.1.1. Although a good chunk of documentation and tests is still missing, the core API is fully functional and the package is ready for use. We are currently working on filling in the gaps and aim to release a more polished update (v0.2.0) in the near future.","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Created by Luis M. B. Varona, Dr. Nathaniel Johnston, and Dr. Sarah Plosker.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Insights from Benjamin Talbot, Logan Pipes, and Dr. Liam Keliher are gratefully acknowledged.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional thanks to Madiha Waqar for the GraphQuantum logo and Luc Campbell for code review.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
