var documenterSearchIndex = {"docs":
[{"location":"public_api/#SDiagonalizability.jl-–-Public-API","page":"Public API","title":"SDiagonalizability.jl – Public API","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"Documentation for SDiagonalizability's public API.","category":"page"},{"location":"public_api/","page":"Public API","title":"Public API","text":"note: Note\nThe following documentation covers only the public API of the package. For internal details, see the private API documentation.","category":"page"},{"location":"public_api/#SDiagonalizability.SDiagonalizability","page":"Public API","title":"SDiagonalizability.SDiagonalizability","text":"SDiagonalizability\n\nA dynamic algorithm to minimize or recognize a graph's S-bandwidth.\n\n[TODO: Write here]\n\n\n\n\n\n","category":"module"},{"location":"public_api/#References","page":"Public API","title":"References","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"<!– @bibliography Pages = [@__FILE__] –>","category":"page"},{"location":"private_api/#SDiagonalizability.jl-–-Private-API","page":"Private API","title":"SDiagonalizability.jl – Private API","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"Documentation for SDiagonalizability's private API.","category":"page"},{"location":"private_api/","page":"Private API","title":"Private API","text":"note: Note\nThe following documentation covers only the private API of the package. For public details, see the public API documentation.","category":"page"},{"location":"private_api/#SDiagonalizability.AbstractSBandResult","page":"Private API","title":"SDiagonalizability.AbstractSBandResult","text":"AbstractSBandResult\n\nAbstract base type for all S-bandwidth problem results.\n\nInterface\n\nConcrete subtypes of AbstractSBandResult must implement parametric types\n\nA<:Union{AbstractGraph,AbstractMatrix{<:Integer}};\nB<:Tuple; and\nC<:Union{Nothing,Eigen},\n\nalongside the following fields:\n\nnetwork::A: the network whose S-bandwidth is investigated;\nS::B: the set S from whose entries we are allowed to construct eigenvectors;\ndiagonalization::C: an S-diagonalization of the matrix representation of the network,   if it satisfies the specified S-bandwidth constraints; otherwise, nothing.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.EfficiencyWarning","page":"Private API","title":"SDiagonalizability.EfficiencyWarning","text":"EfficiencyWarning(msg)\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.NotImplementedError","page":"Private API","title":"SDiagonalizability.NotImplementedError","text":"NotImplementedError{Nothing}(f, subtype, abstracttype)\nNotImplementedError{Symbol}(f, arg, subtype, abstracttype)\n\nAn exception indicating that a function lacks dispatch to handle a specific argument type.\n\nSemantically, this differs from MethodError in that it connotes a developer-side failure to implement a method rather than erroneous user input. Throughout this package, it is often used to warn when an existing function with multiple dispatch on some abstract type is called on a newly created subtype for which no method has been defined.\n\nFields\n\nf::Function: the function called.\narg::Symbol: the name of the argument with the unsupported type, if the function has   multiple arguments. If the function has only one argument, this field should be set to   nothing.\nsubtype::Type: the type of the argument. May be the actual concrete type or some   intermediate supertype. (For instance, if the relevant input has concrete type A with   hierarchy A <: B <: C and the abstracttype field is C, then both A and B are   perfectly valid choices for subtype.)\nabstracttype::Type: the abstract type under which the argument is meant to fall.\n\nConstructors\n\nNotImplementedError(::Function, ::Type, ::Type): constructs a new NotImplementedError   instance for a single-argument function. Throws an error if the second type is not   abstract or the first type is not a subtype of the second.\nNotImplementedError(::Function, ::Symbol, ::Type, ::Type): constructs a new   NotImplementedError instance for a multi-argument function. Throws an error if the   second type is not abstract or the first type is not a subtype of the second.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SBandMinimizationResult","page":"Private API","title":"SDiagonalizability.SBandMinimizationResult","text":"SBandMinimizationResult{A,B,C,D} <: AbstractSBandResult\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SBandRecognitionResult","page":"Private API","title":"SDiagonalizability.SBandRecognitionResult","text":"SBandRecognitionResult{A,B,C} <: AbstractSBandResult\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability.SpectrumIntegralResult","page":"Private API","title":"SDiagonalizability.SpectrumIntegralResult","text":"struct SpectrumIntegralResult\n\nData on whether a matrix is spectrum integral (i.e., whether its eigenvalues are integers).\n\nThis struct also contains a map from each eigenvalue to its multiplicity, provided that the eigenvalues are indeed all integers. (Otherwise, the associated field is simply nothing.)\n\nFields\n\nmatrix::Matrix{Int}: the matrix whose eigenvalues and their integrality are of interest.\nspectrum_integral::Bool: whether the eigenvalues of matrix are all integers.\nmultiplicities::Union{Nothing,OrderedDict{Int,Int}}: a map from each eigenvalue to its   multiplicity, sorted first by ascending multiplicity then by ascending eigenvalue. (This   field is nothing if and only if spectrum_integral is false, since we cannot map   non-integer eigenvalues to data.)\n\nNotes\n\nIf an undirected graph with integer edge weights is {-1,0,1}-diagonalizable (or, more restrictively, {-1,1}-diagonalizable), then its Laplacian matrix has integer eigenvalues [JP25, p. 312]. Hence, validating Laplacian integrality serves as a useful screening step in this package's principal S-bandwidth minimization algorithm.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#SDiagonalizability._SSpectra","page":"Private API","title":"SDiagonalizability._SSpectra","text":"_SSpectra{A,B,C,D}\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"private_api/#LinearAlgebra.rank","page":"Private API","title":"LinearAlgebra.rank","text":"rank(A::QRPivoted{<:Any, T}; atol::Real=0, rtol::Real=min(n,m)*ϵ) where {T}\n\nCompute the numerical rank of the QR factorization A by counting how many diagonal entries of A.factors are greater than max(atol, rtol*Δ₁) where Δ₁ is the largest calculated such entry. This is similar to the rank(::AbstractMatrix) method insofar as it counts the number of (numerically) nonzero coefficients from a matrix factorization, although the default method uses an SVD instead of a QR factorization. Like rank(::SVD), this method also re-uses an existing matrix factorization.\n\nComputing rank via QR factorization should almost always produce the same results as via SVD, although this method may be more prone to overestimating the rank in pathological cases where the matrix is ill-conditioned. It is also worth noting that it is generally faster to compute a QR factorization than an SVD, so this method may be preferred when performance is a concern.\n\natol and rtol are the absolute and relative tolerances, respectively. The default relative tolerance is n*ϵ, where n is the size of the smallest dimension of A and ϵ is the eps of the element type of A.\n\n\n\n\n\n","category":"function"},{"location":"private_api/#SDiagonalizability._assert_matrix_is_undirected_laplacian-Tuple{AbstractMatrix{<:Integer}}","page":"Private API","title":"SDiagonalizability._assert_matrix_is_undirected_laplacian","text":"_assert_matrix_is_undirected_laplacian(L)\n\nValidate that L is the Laplacian matrix of an undirected, possibly weighted graph.\n\nArguments\n\nL::AbstractMatrix{<:Integer}: the purported Laplacian matrix.\n\nReturns\n\nnothing: if the check is passed, no output is produced.\n\nThrows\n\nDomainError: if L is not symmetric or has nonzero row sums.\n\nExamples\n\nThe Laplacian matrix of the (undirected) star graph on 5 vertices passes the check:\n\njulia> L = [ 4  -1  -1  -1  -1;\n            -1   1   0   0   0;\n            -1   0   1   0   0;\n            -1   0   0   1   0;\n            -1   0   0   0   1]\n5×5 Matrix{Int64}:\n  4  -1  -1  -1  -1\n -1   1   0   0   0\n -1   0   1   0   0\n -1   0   0   1   0\n -1   0   0   0   1\n\njulia> isnothing(SDiagonalizability._assert_matrix_is_undirected_laplacian(L))\ntrue\n\nThe adjacency matrix of the (undirected) cycle graph on 4 vertices is symmetric but has nonzero row sums, so it fails the check:\n\njulia> A = [0  1  0  1;\n            1  0  1  0;\n            0  1  0  1;\n            1  0  1  0]\n4×4 Matrix{Int64}:\n 0  1  0  1\n 1  0  1  0\n 0  1  0  1\n 1  0  1  0\n\njulia> SDiagonalizability._assert_matrix_is_undirected_laplacian(A)\nERROR: DomainError with [0 1 0 1; 1 0 1 0; 0 1 0 1; 1 0 1 0]:\nMatrix has nonzero row sums; cannot be an (undirected) Laplacian\n[...]\n\nBoth the in-degree and out-degree Laplacian matrices of this random tournament digraph have zero row sums but are not symmetric, so they fail the check. (These are the two standard ways of extending the concept of the Laplacian to directed graphs [VL20, p. 196].)\n\njulia> using Graphs\n\njulia> G = random_tournament_digraph(3; seed=87)\n{3, 3} directed simple Int64 graph\n\njulia> L_in = laplacian_matrix(G; dir=:in)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n  ⋅  ⋅   ⋅\n -1  2  -1\n -1  ⋅   1\n\njulia> SDiagonalizability._assert_matrix_is_undirected_laplacian(L_in)\nERROR: DomainError with sparse([2, 3, 2, 2, 3], [1, 1, 2, 3, 3], [-1, -1, 2, -1, 1], 3, 3):\nMatrix is not symmetric; cannot be an (undirected) Laplacian\n[...]\n\njulia> L_out = laplacian_matrix(G; dir=:out)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n 2  -1  -1\n ⋅   ⋅   ⋅\n ⋅  -1   1\n\njulia> SDiagonalizability._assert_matrix_is_undirected_laplacian(L_out)\nERROR: DomainError with sparse([1, 1, 3, 1, 3], [1, 2, 2, 3, 3], [2, -1, -1, -1, 1], 3, 3):\nMatrix is not symmetric; cannot be an (undirected) Laplacian\n[...]\n\nNotes\n\nIf edges are to be bidirectional, then L must be symmetric. L must also have zero row sums, since the (i, i)-th entry is the weighted degree of node i (the sum of all incident edges' weights) and the (i, j)-th entry for i ≠ j is the negation of the weight of edge (i, j) (or simply 0, if no such edge exists).\n\nGiven the highly optimized, lazy, zero-allocation implementation of LinearAlgebra.issymmetric, the symmetry check is performed first. (Both steps are O(n²) in the worst case, but testing for symmetry is far more performant in practice.) This also allows us to (also lazily) check for nonzero column sums rather than nonzero row sums (since these are equivalent for symmetric matrices) in the second step, taking advantage of Julia's column-major storage model.\n\nAt first blush, it may seem as though the choice of DomainError over something like ArgumentError (or even simply the return of a boolean) constitutes poor design. However, this is informed by the simple ad hoc use of this function to validate inputs for other functions requiring Laplacian matrices. Certainly, this function is never meant to be publicly exposed on its own.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_kernel_01neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_kernel_01neg_eigvecs","text":"_pot_kernel_01neg_eigvecs(n)\n\nLazily generate all potential kernel {-1,0,1}-eigenvectors of an order n Laplacian.\n\nEach vector is normalized so that its first nonzero entry is 1, enforcing pairwise linear independence between all generated vectors.\n\nArguments\n\nn::Integer: the order of the Laplacian matrix of some undirected graph for which to find   potential kernel eigenvectors.\n\nReturns\n\neigvec_generator::Iterators.Flatten{<:Base.Generator}: a lazily evaluated iterator over   all {-1,0,1}-vectors in ℝⁿ, unique up to span.\n\nExamples\n\nGenerate all potential kernel eigenvectors for an order 3 Laplacian matrix:\n\njulia> hcat(SDiagonalizability._pot_kernel_01neg_eigvecs(3)...)\n3×13 Matrix{Int64}:\n  1   1   1   1  1  1   1  1  1   0  0  0  0\n -1  -1  -1   0  0  0   1  1  1   1  1  1  0\n -1   0   1  -1  0  1  -1  0  1  -1  0  1  1\n\nNotes\n\nThe number of potential kernel eigenvectors (unique up to span) for an order n Laplacian matrix is given by (3ⁿ - 1) / 2. See also the relevant OEIS sequence [Slo25].\n\nRegrettably, the implementation here is rather clunky and unidiomatic, but it is worth noting that eigenvector generation is one of two major bottlenecks in the overall S-bandwidth minimization algorithm. Given how much potential there is for optimization in this piece of code, we thus prioritize performance over readability in this particular case, making every effort to include inline comments wherever clarification may be needed.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_kernel_1neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_kernel_1neg_eigvecs","text":"_pot_kernel_1neg_eigvecs(n)\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_nonkernel_01neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_nonkernel_01neg_eigvecs","text":"_pot_nonkernel_01neg_eigvecs(n)\n\nLazily generate all potential non-kernel {-1,0,1}-eigenvectors of an order n Laplacian.\n\nEach vector is normalized so that its first nonzero entry is 1, enforcing pairwise linear independence between all generated vectors. Since all Laplacian matrices have pairwise orthogonal eigenspaces and the all-ones vector is always in the kernel, every non-kernel {-1,0,1}-eigenvector must also have an equal number of -1's and 1's.\n\nArguments\n\nn::Integer: the order of the Laplacian matrix of some undirected graph for which to find   potential non-kernel eigenvectors.\n\nReturns\n\neigvec_generator::Iterators.Flatten{<:Base.Generator}: a lazily evaluated iterator over   all {-1,0,1}-vectors in ℝⁿ orthogonal to the all-ones kernel vector, unique up to   span.\n\nExamples\n\nGenerate all potential non-kernel eigenvectors of an order 4 Laplacian matrix:\n\njulia> hcat(SDiagonalizability._pot_nonkernel_01neg_eigvecs(4)...)\n4×9 Matrix{Int64}:\n  1   1   1   1   1   1   0   0   0\n -1   0   0  -1  -1   1   1   1   0\n  0  -1   0  -1   1  -1  -1   0   1\n  0   0  -1   1  -1  -1   0  -1  -1\n\nNotes\n\nThe number of potential non-kernel eigenvectors (unique up to span) for an order n Laplacian matrix is, by non-trivial combinatorial arguments, equal to the number of humps in all Motzkin paths of length n. See also the relevant OEIS sequence [Deu25].\n\nRegrettably, the implementation here is rather clunky and unidiomatic, but it is worth noting that eigenvector generation is one of two major bottlenecks in the overall S-bandwidth minimization algorithm. Given how much potential there is for optimization in this piece of code, we thus prioritize performance over readability in this particular case, making every effort to include inline comments wherever clarification may be needed.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._pot_nonkernel_1neg_eigvecs-Tuple{Integer}","page":"Private API","title":"SDiagonalizability._pot_nonkernel_1neg_eigvecs","text":"_pot_nonkernel_1neg_eigvecs(n)\n\n[TODO: Write here. Also, comment inline]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability._rank_rtol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Private API","title":"SDiagonalizability._rank_rtol","text":"function _rank_rtol(A::AbstractMatrix{<:Real})\n\nReturn a reasonable relative tolerance for computing matrix rank via SVD or QRD.\n\nThe output is intended to be passed as a keyword argument to LinearAlgebra.rank. LinearAlgebra.eigtype is used to determine the appropriate machine epsilon for the element type of A when eltype(A) is not an AbstractFloat.\n\nArguments\n\nA::AbstractMatrix{<:Real}: the matrix for which to compute a tolerance.\n\nReturns\n\ntol::Float64: a reasonable relative tolerance for computing matrix rank via SVD or QRD.   This scales proportionally to the maximum dimension of A.\n\nNotes\n\nLinearAlgebra.rank's default rtol of min(m,n) * ϵ for computing the rank of an m × n matrix may result in overestimating rank when |m - n| ≫ 0, since condition number (which determines how numerically stable SVD and QRD are) grows with both dimensions [CD05, p. 603]. Given that we often deal with short-and-fat matrices in this package (particularly when processing all {-1,0,1}-eigenvectors of a Laplacian matrix), we turn instead to the same relative tolerance used by NumPy's and MATLAB's rank functions—max(m,n) * ϵ [Num25, MAT25]. (Indeed, this is a widely adopted standard across the field of numerical analysis [PTVF07, p. 795].)\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.pot_kernel_s_eigvecs-Tuple{Tuple, Integer}","page":"Private API","title":"SDiagonalizability.pot_kernel_s_eigvecs","text":"pot_kernel_s_eigvecs(S, n)\n\n[TODO: Write here]\n\nThrows\n\nDomainError: if n is negative.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#SDiagonalizability.pot_nonkernel_s_eigvecs-Tuple{Tuple, Integer}","page":"Private API","title":"SDiagonalizability.pot_nonkernel_s_eigvecs","text":"pot_nonkernel_s_eigvecs(S, n)\n\n[TODO: Write here]\n\nThrows\n\nDomainError: if n is negative.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#References","page":"Private API","title":"References","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"Z. Chen and J. Dongarra. Condition Numbers of Gaussian Random Matrices. SIAM Journal on Matrix Analysis and Applications 27, 603–20 (2005).\n\n\n\nE. Deutsch. Number of humps in all Motzkin paths of length n. Entry A097861 (2025). Accessed: 2025-05-22.\n\n\n\nN. Johnston and S. Plosker. Laplacian {−1,0,1}- and {−1,1}-diagonalizable graphs. Linear Algebra and its Applications 704, 309–39 (2025).\n\n\n\nW. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery. Numerical Recipes: The Art of Scientific Computing. 3rd Edition (Cambridge University Press, Cambridge, UK, 2007). ISBN: 978-0-521-88068-8.\n\n\n\nN. J. Sloane, a(n) = (3^n - 1)/2. Entry A003462 (2025). Accessed: 2025-05-22.\n\n\n\nJ. J. Veerman and R. Lyons. A Primer on Laplacian Dynamics in Directed Graphs. Nonlinear Phenomena in Complex Systems 23, 196–206 (2020).\n\n\n\nMATLAB Developers, rank. MATLAB reference documentation – R2025a (2025). Accessed: 2025-05-29.\n\n\n\nNumPy Developers, numpy.linalg.matrix_rank. NumPy reference documentation – v2.2 (2025). Accessed: 2025-05-22.\n\n\n\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"<table>\n  <tr>\n    <td>Metadata</td>\n    <td>\n      <img src=\"https://img.shields.io/badge/version-v0.1.0--dev-pink.svg\" alt=\"Version\">\n      <a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/License-MIT-A31F34.svg\" alt=\"License: MIT\"></a>\n      <a href=\"https://github.com/JuliaDiff/BlueStyle\"><img src=\"https://img.shields.io/badge/code%20style-blue-4495d1.svg\" alt=\"Code Style: Blue\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Documentation</td>\n    <td>\n      <a href=\"https://graphquantum.github.io/SDiagonalizability.jl/stable/\"><img src=\"https://img.shields.io/badge/docs-stable-darkgreen.svg\" alt=\"Documentation of latest stable version\"></a>\n      <a href=\"https://graphquantum.github.io/SDiagonalizability.jl/dev/\"><img src=\"https://img.shields.io/badge/docs-dev-rebeccapurple.svg\" alt=\"Documentation of dev version\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Continuous integration</td>\n    <td>\n      <a href=\"https://github.com/GraphQuantum/SDiagonalizability.jl/actions?query=workflow%3ACI+branch%3Amain\"><img src=\"https://github.com/GraphQuantum/SDiagonalizability.jl/actions/workflows/CI.yml/badge.svg\" alt=\"GitHub Workflow Status\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Code coverage</td>\n    <td>\n      <a href=\"https://codecov.io/gh/GraphQuantum/SDiagonalizability.jl\"><img src=\"https://codecov.io/gh/GraphQuantum/SDiagonalizability.jl/branch/main/graph/badge.svg\" alt=\"Test coverage from codecov\"></a>\n    </td>\n    </tr>\n    <tr>\n      <td>Static analysis with</td>\n      <td>\n        <a href=\"https://github.com/JuliaTesting/Aqua.jl\"><img src=\"https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg\" alt=\"Aqua QA\"></a>\n        <a href=\"https://github.com/aviatesk/JET.jl\"><img src=\"https://img.shields.io/badge/%E2%9C%88%20tested%20with-JET.jl%EF%B8%8F-9cf.svg\" alt=\"JET static analysis\"></a>\n      </td>\n    </tr>\n</table>","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[TODO: Write here]","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The only prerequisite is a working Julia installation (v1.10 or later). First, enter Pkg mode by typing ] in the Julia REPL, then run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/GraphQuantum/SDiagonalizability.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once SDiagonalizability.jl is added to Julia's General package registry, you will be able to install it more easily with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SDiagonalizability","category":"page"},{"location":"#Basic-use","page":"Home","title":"Basic use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[TODO: Write here]","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The full documentation is available at GitHub Pages. Documentation for methods and types is also available via the Julia REPL. [TODO: Write here]","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We encourage you to cite our work if you have used our algorithm in your research. Starring the SDiagonalizability.jl repository on GitHub is also appreciated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latest citation information may be found in the CITATION.bib file within the repository.","category":"page"},{"location":"#Project-status","page":"Home","title":"Project status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[TODO: Write here]","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Created by Luis M. B. Varona, Dr. Nathaniel Johnston, and Dr. Sarah Plosker.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Insights from Benjamin Talbot, Logan Pipes, and Dr. Liam Keliher are gratefully acknowledged.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional thanks to Madiha Waqar for the GraphQuantum logo and Luc Campbell for code review.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
