<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Private API · SDiagonalizability.jl</title><meta name="title" content="Private API · SDiagonalizability.jl"/><meta property="og:title" content="Private API · SDiagonalizability.jl"/><meta property="twitter:title" content="Private API · SDiagonalizability.jl"/><meta name="description" content="Documentation for SDiagonalizability.jl."/><meta property="og:description" content="Documentation for SDiagonalizability.jl."/><meta property="twitter:description" content="Documentation for SDiagonalizability.jl."/><meta property="og:url" content="https://GraphQuantum.github.io/SDiagonalizability.jl/private_api/"/><meta property="twitter:url" content="https://GraphQuantum.github.io/SDiagonalizability.jl/private_api/"/><link rel="canonical" href="https://GraphQuantum.github.io/SDiagonalizability.jl/private_api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.jpg" alt="SDiagonalizability.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SDiagonalizability.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../public_api/">Public API</a></li><li class="is-active"><a class="tocitem" href>Private API</a><ul class="internal"><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Private API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Private API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GraphQuantum/SDiagonalizability.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/main/docs/src/private_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SDiagonalizability.jl-–-Private-API"><a class="docs-heading-anchor" href="#SDiagonalizability.jl-–-Private-API">SDiagonalizability.jl – Private API</a><a id="SDiagonalizability.jl-–-Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#SDiagonalizability.jl-–-Private-API" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/GraphQuantum/SDiagonalizability.jl">SDiagonalizability</a>&#39;s private API.</p><div class="admonition is-info" id="Note-e146e82dfde0b0fe"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e146e82dfde0b0fe" title="Permalink"></a></header><div class="admonition-body"><p>The following documentation covers only the private API of the package. For public details, see the <a href="../public_api/">public API documentation</a>.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.AbstractSDiagResult" href="#SDiagonalizability.AbstractSDiagResult"><code>SDiagonalizability.AbstractSDiagResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSDiagResult</code></pre><p>Abstract base type for all <em>S</em>-diagonalizability and <em>S</em>-bandwidth problem results.</p><p><strong>Interface</strong></p><p>Concrete subtypes of <code>AbstractSDiagResult</code> <em>must</em> implement parametric types</p><ul><li><code>A&lt;:Union{AbstractGraph,AbstractMatrix{&lt;:Integer}}</code>;</li><li><code>B&lt;:Tuple{Vararg{Integer}}</code>; and</li><li><code>C&lt;:Union{Nothing,Eigen}</code>,</li></ul><p>alongside the following fields:</p><ul><li><code>network::A</code>: the network whose <em>S</em>-bandwidth is investigated;</li><li><code>S::B</code>: the set <em>S</em> from whose entries we are allowed to construct eigenvectors;</li><li><code>diagonalization::C</code>: an <em>S</em>-diagonalization of the matrix representation of the network,   if it satisfies the specified <em>S</em>-bandwidth constraints; otherwise, <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.ArbitraryGraphLaplacian" href="#SDiagonalizability.ArbitraryGraphLaplacian"><code>SDiagonalizability.ArbitraryGraphLaplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArbitraryGraphLaplacian &lt;: ClassifiedLaplacian</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>ArbitraryGraphLaplacian</code> &lt;: <a href="#SDiagonalizability.ClassifiedLaplacian"><code>ClassifiedLaplacian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/laplacian_factory.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.ClassifiedLaplacian" href="#SDiagonalizability.ClassifiedLaplacian"><code>SDiagonalizability.ClassifiedLaplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClassifiedLaplacian</code></pre><p>An abstract type representing a classified Laplacian matrix of an undirected graph.</p><p><strong>Interface</strong></p><p>Concrete subtypes of <code>_TypedLaplacian</code> <em>must</em> implement the following fields:</p><ul><li><code>matrix::Matrix{Int}</code>: the Laplacian matrix of the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/laplacian_factory.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.CompleteGraphLaplacian" href="#SDiagonalizability.CompleteGraphLaplacian"><code>SDiagonalizability.CompleteGraphLaplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompleteGraphLaplacian &lt;: ClassifiedLaplacian</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>CompleteGraphLaplacian</code> &lt;: <a href="#SDiagonalizability.ClassifiedLaplacian"><code>ClassifiedLaplacian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/laplacian_factory.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.EfficiencyWarning" href="#SDiagonalizability.EfficiencyWarning"><code>SDiagonalizability.EfficiencyWarning</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EfficiencyWarning(msg)</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.EmptyGraphLaplacian" href="#SDiagonalizability.EmptyGraphLaplacian"><code>SDiagonalizability.EmptyGraphLaplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EmptyGraphLaplacian &lt;: ClassifiedLaplacian</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>EmptyGraphLaplacian</code> &lt;: <a href="#SDiagonalizability.ClassifiedLaplacian"><code>ClassifiedLaplacian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/laplacian_factory.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.KOrthogonality" href="#SDiagonalizability.KOrthogonality"><code>SDiagonalizability.KOrthogonality</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KOrthogonality</code></pre><p>An abstract type representing the property of <code>k</code>-orthogonality of a collection of vectors.</p><p>Recall that an (ordered) collection of vectors <span>$v₁, v₂, ..., vₙ$</span> is said to be <em><span>$k$</span>-orthogonal</em> if we have the inner product <span>$⟨`vᵢ, vⱼ⟩ = 0$</span> whenever <span>$|i - j| ≥ k$</span> (i.e., if every pair of vectors at least <span>$k$</span> indices apart is orthogonal). This is equivalent to the vectors&#39; Gram matrix having bandwidth at most <code>k</code>, where we define the bandwidth of a matrix <span>$A$</span> to be the minimum integer <span>$k ∈ \{1, 2, …, n\}$</span> such that <span>$Aᵢⱼ = 0$</span> whenever <span>$|i - j| ≥ k$</span> [<a href="#JP25">JP25</a>, p. 313]. (Note that many texts instead define matrix bandwidth using zero-based indexing—that is, with the condition <span>$|i - j| &gt; k$</span> [<a href="#Maf14">Maf14</a>, p. 186].)</p><p>This type is used as a template for concretely defined properties corresponding to specific values of <span>$k$</span>. In the context of the overarching <em>S</em>-bandwidth algorithm, we perform a different depth-first search for each family of values of <span>$k$</span> on our &quot;tree&quot; of <em>S</em>-eigenvectors to determine whether there exists a <span>$k$</span>-orthogonal collection of them.</p><p><strong>Interface</strong></p><p>Concrete subtypes of <code>KOrthogonality</code> <strong>must</strong> implement the following fields:</p><ul><li><code>k::Int</code>: the <span>$k$</span>-orthogonality parameter. Must be a positive integer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/orthogonality_factory.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.NotImplementedError" href="#SDiagonalizability.NotImplementedError"><code>SDiagonalizability.NotImplementedError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NotImplementedError{Nothing}(f, subtype, abstracttype)
NotImplementedError{Symbol}(f, arg, subtype, abstracttype)</code></pre><p>An exception indicating that a function lacks dispatch to handle a specific argument type.</p><p>Semantically, this differs from <code>MethodError</code> in that it connotes a developer-side failure to implement a method rather than erroneous user input. Throughout this package, it is often used to warn when an existing function with multiple dispatch on some abstract type is called on a newly created subtype for which no method has been defined.</p><p><strong>Fields</strong></p><ul><li><code>f::Function</code>: the function called.</li><li><code>arg::Symbol</code>: the name of the argument with the unsupported type, if the function has   multiple arguments. If the function has only one argument, this field should be set to   <code>nothing</code>.</li><li><code>subtype::Type</code>: the type of the argument. May be the actual concrete type or some   intermediate supertype. (For instance, if the relevant input has concrete type <code>A</code> with   hierarchy <code>A &lt;: B &lt;: C</code> and the <code>abstracttype</code> field is <code>C</code>, then both <code>A</code> and <code>B</code> are   perfectly valid choices for <code>subtype</code>.)</li><li><code>abstracttype::Type</code>: the abstract type under which the argument is meant to fall.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>NotImplementedError</code> &lt;: <code>Exception</code></p><p><strong>Constructors</strong></p><ul><li><code>NotImplementedError(::Function, ::Type, ::Type)</code>: constructs a new <code>NotImplementedError</code>   instance for a single-argument function. Throws an error if the second type is not   abstract or the first type is not a subtype of the second.</li><li><code>NotImplementedError(::Function, ::Symbol, ::Type, ::Type)</code>: constructs a new   <code>NotImplementedError</code> instance for a multi-argument function. Throws an error if the   second type is not abstract or the first type is not a subtype of the second.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L182-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.NullGraphLaplacian" href="#SDiagonalizability.NullGraphLaplacian"><code>SDiagonalizability.NullGraphLaplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NullGraphLaplacian &lt;: ClassifiedLaplacian</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>NullGraphLaplacian</code> &lt;: <a href="#SDiagonalizability.ClassifiedLaplacian"><code>ClassifiedLaplacian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/laplacian_factory.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.Orthogonality" href="#SDiagonalizability.Orthogonality"><code>SDiagonalizability.Orthogonality</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Orthogonality &lt;: KOrthogonality</code></pre><p>The property of pairwise orthogonality for a collection of vectors.</p><p>Recall that a collection of vectors <span>$v₁, v₂, ..., vₙ$</span> is said to be pairwise <em>orthogonal</em> if we have the inner product <span>$⟨vᵢ, vⱼ⟩ = 0$</span> whenever <span>$|i - j| ≥ 1$</span> (i.e., if every pair of vectors is orthogonal). This is equivalent to the vectors&#39; Gram matrix being diagonal.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: the <span>$k$</span>-orthogonality parameter; always necessarily <span>$1$</span>.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>Orthogonality</code> &lt;: <a href="#SDiagonalizability.KOrthogonality"><code>KOrthogonality</code></a></p><p><strong>Constructors</strong></p><ul><li><code>Orthogonality()</code>: constructs a new <code>Orthogonality</code> object with <code>k = 1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/orthogonality_factory.jl#L32-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.QuasiOrthogonality" href="#SDiagonalizability.QuasiOrthogonality"><code>SDiagonalizability.QuasiOrthogonality</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiOrthogonality &lt;: KOrthogonality</code></pre><p>The property of quasi-orthogonality for a collection of vectors.</p><p>Recall that an (ordered) collection of vectors <span>$v₁, v₂, ..., vₙ$</span> is said to be <em>quasi-orthogonal</em> if we have the inner product <span>$⟨vᵢ, vⱼ⟩ = 0$</span> whenever <span>$|i - j| ≥ 2$</span> (i.e., if every pair of vectors at least <span>$2$</span> indices apart is orthogonal). This is equivalent to the vectors&#39; Gram matrix being tridiagonal [<a href="#JP25">JP25</a>, p. 313].</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: the <span>$k$</span>-orthogonality parameter; always necessarily <span>$2$</span>.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>QuasiOrthogonality</code> &lt;: <a href="#SDiagonalizability.KOrthogonality"><code>KOrthogonality</code></a></p><p><strong>Constructors</strong></p><ul><li><code>QuasiOrthogonality()</code>: constructs a new <code>QuasiOrthogonality</code> object with <code>k = 2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/orthogonality_factory.jl#L56-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.SBandMinimizationResult" href="#SDiagonalizability.SBandMinimizationResult"><code>SDiagonalizability.SBandMinimizationResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SBandMinimizationResult{A,B,C,D} &lt;: AbstractSDiagResult</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>SBandMinimizationResult</code> &lt;: <a href="#SDiagonalizability.AbstractSDiagResult"><code>AbstractSDiagResult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.SBandRecognitionResult" href="#SDiagonalizability.SBandRecognitionResult"><code>SDiagonalizability.SBandRecognitionResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SBandRecognitionResult{A,B,C} &lt;: AbstractSDiagResult</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>SBandRecognitionResult</code> &lt;: <a href="#SDiagonalizability.AbstractSDiagResult"><code>AbstractSDiagResult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.SDiagonalizabilityResult" href="#SDiagonalizability.SDiagonalizabilityResult"><code>SDiagonalizability.SDiagonalizabilityResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDiagonalizabilityResult{A,B,C} &lt;: AbstractSDiagResult</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.SSpectra" href="#SDiagonalizability.SSpectra"><code>SDiagonalizability.SSpectra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSpectra{A,B,C,D,E}</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.SpectrumIntegralResult" href="#SDiagonalizability.SpectrumIntegralResult"><code>SDiagonalizability.SpectrumIntegralResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SpectrumIntegralResult</code></pre><p>Data on whether a matrix is spectrum integral (i.e., whether its eigenvalues are integers).</p><p>This struct also contains a map from each eigenvalue to its multiplicity, provided that the eigenvalues are indeed all integers. (Otherwise, the associated field is simply <code>nothing</code>.)</p><p><strong>Fields</strong></p><ul><li><code>matrix::Matrix{Int}</code>: the matrix whose eigenvalues and their integrality are of interest.</li><li><code>spectrum_integral::Bool</code>: whether the eigenvalues of <code>matrix</code> are all integers.</li><li><code>multiplicities::Union{Nothing,OrderedDict{Int,Int}}</code>: a map from each eigenvalue to its   multiplicity, sorted first by ascending multiplicity then by ascending eigenvalue. (This   field is <code>nothing</code> if and only if <code>spectrum_integral</code> is false, since we cannot map   non-integer eigenvalues to data.)</li></ul><p><strong>Notes</strong></p><p>If an undirected graph with integer edge weights is <span>$\{-1, 0, 1\}$</span>-diagonalizable (or, more restrictively, <span>$\{-1, 1\}$</span>-diagonalizable), then its Laplacian matrix has integer eigenvalues [<a href="#JP25">JP25</a>, p. 312]. Hence, validating Laplacian integrality serves as a useful screening step in this package&#39;s principal <em>S</em>-bandwidth minimization algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/types.jl#L154-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.WeakOrthogonality" href="#SDiagonalizability.WeakOrthogonality"><code>SDiagonalizability.WeakOrthogonality</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeakOrthogonality &lt;: KOrthogonality</code></pre><p>The property of &quot;weak orthogonality&quot; for a collection of vectors.</p><p>In particular, &quot;weak orthogonality&quot; is an <em>ad hoc</em> term used to refer to the property of <span>$k$</span>-orthogonality for <span>$k &gt; 2$</span>. Recall that an (ordered) collection of vectors <span>$v₁, v₂, ..., vₙ$</span> is said to be <em><code>k</code>-orthogonal</em> if we have the inner product <span>$⟨vᵢ, vⱼ⟩ = 0$</span> whenever <span>$|i - j| ≥ k$</span> (i.e., if every pair of vectors at least <span>$k$</span> indices apart is orthogonal). This is equivalent to the vectors&#39; Gram matrix having bandwidth at most <span>$k$</span>.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: the <span>$k$</span>-orthogonality parameter. Must be greater than <span>$2$</span>.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>WeakOrthogonality</code> &lt;: <a href="#SDiagonalizability.KOrthogonality"><code>KOrthogonality</code></a></p><p><strong>Notes</strong></p><p>The term &quot;weak orthogonality&quot; is not standard terminology in the literature, but it is used here to emphasize the weaker nature of this property compared to orthogonality and quasi-orthogonality. It is an <em>ad hoc</em> term coined for this module and is not intended to be formally introduced in the broader literature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/orthogonality_factory.jl#L81-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._QOBasisSearchNode" href="#SDiagonalizability._QOBasisSearchNode"><code>SDiagonalizability._QOBasisSearchNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_QOBasisSearchNode</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/basis_search.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rank" href="#LinearAlgebra.rank"><code>LinearAlgebra.rank</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank(A::QRPivoted{&lt;:Any, T}; atol::Real=0, rtol::Real=min(n,m)*ϵ) where {T}</code></pre><p>Compute the numerical rank of the QR factorization <code>A</code> by counting how many diagonal entries of <code>A.factors</code> are greater than <code>max(atol, rtol*Δ₁)</code> where <code>Δ₁</code> is the largest calculated such entry. This is similar to the <code>rank(::AbstractMatrix)</code> method insofar as it counts the number of (numerically) nonzero coefficients from a matrix factorization, although the default method uses an SVD instead of a QR factorization. Like <code>rank(::SVD)</code>, this method also re-uses an existing matrix factorization.</p><p>Computing rank via QR factorization should almost always produce the same results as via SVD, although this method may be more prone to overestimating the rank in pathological cases where the matrix is ill-conditioned. It is also worth noting that it is generally faster to compute a QR factorization than an SVD, so this method may be preferred when performance is a concern.</p><p><code>atol</code> and <code>rtol</code> are the absolute and relative tolerances, respectively. The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of the smallest dimension of <code>A</code> and <code>ϵ</code> is the <code>eps</code> of the element type of <code>A</code>.</p><div class="admonition is-info" id="Note-4719e989163c843d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4719e989163c843d" title="Permalink"></a></header><div class="admonition-body"><p>When accessed directly via <code>LinearAlgebra</code>, the <code>rank(::QRPivoted)</code> method requires at least Julia 1.12, so <code>SDiagonalizability</code> defines this method manually for compatibility with v1.10–1.11.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/utils.jl#L267-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._assert_graph_has_defined_s_bandwidth-Tuple{Graphs.AbstractGraph}" href="#SDiagonalizability._assert_graph_has_defined_s_bandwidth-Tuple{Graphs.AbstractGraph}"><code>SDiagonalizability._assert_graph_has_defined_s_bandwidth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_assert_graph_has_defined_s_bandwidth(g) -&gt; Nothing</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/utils.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._assert_matrix_is_undirected_laplacian-Tuple{AbstractMatrix{&lt;:Integer}}" href="#SDiagonalizability._assert_matrix_is_undirected_laplacian-Tuple{AbstractMatrix{&lt;:Integer}}"><code>SDiagonalizability._assert_matrix_is_undirected_laplacian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_assert_matrix_is_undirected_laplacian(L) -&gt; Nothing</code></pre><p>Validate that <code>L</code> is the Laplacian matrix of an undirected, possibly weighted graph.</p><p><strong>Arguments</strong></p><ul><li><code>L::AbstractMatrix{&lt;:Integer}</code>: the purported Laplacian matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: if the check is passed, no output is produced.</li></ul><p><strong>Throws</strong></p><ul><li><code>DomainError</code>: if <code>L</code> is not symmetric or has nonzero row sums.</li></ul><p><strong>Examples</strong></p><p>The Laplacian matrix of the (undirected) star graph on <span>$5$</span> vertices passes the check:</p><pre><code class="language-julia-repl hljs">julia&gt; L = [ 4  -1  -1  -1  -1;
            -1   1   0   0   0;
            -1   0   1   0   0;
            -1   0   0   1   0;
            -1   0   0   0   1]
5×5 Matrix{Int64}:
  4  -1  -1  -1  -1
 -1   1   0   0   0
 -1   0   1   0   0
 -1   0   0   1   0
 -1   0   0   0   1

julia&gt; isnothing(SDiagonalizability._assert_matrix_is_undirected_laplacian(L))
true</code></pre><p>The adjacency matrix of the (undirected) cycle graph on <span>$4$</span> vertices is symmetric but has nonzero row sums, so it fails the check:</p><pre><code class="language-julia-repl hljs">julia&gt; A = [0  1  0  1;
            1  0  1  0;
            0  1  0  1;
            1  0  1  0]
4×4 Matrix{Int64}:
 0  1  0  1
 1  0  1  0
 0  1  0  1
 1  0  1  0

julia&gt; SDiagonalizability._assert_matrix_is_undirected_laplacian(A)
ERROR: DomainError with [0 1 0 1; 1 0 1 0; 0 1 0 1; 1 0 1 0]:
Matrix has nonzero row sums; cannot be an (undirected) Laplacian
[...]</code></pre><p>Both the in-degree and out-degree Laplacian matrices of this random tournament digraph have zero row sums but are not symmetric, so they fail the check. (These are the two standard ways of extending the concept of the Laplacian to directed graphs [<a href="#VL20">VL20</a>, p. 196].)</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = random_tournament_digraph(3; seed=87)
{3, 3} directed simple Int64 graph

julia&gt; L_in = laplacian_matrix(G; dir=:in)
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:
  ⋅  ⋅   ⋅
 -1  2  -1
 -1  ⋅   1

julia&gt; SDiagonalizability._assert_matrix_is_undirected_laplacian(L_in)
ERROR: DomainError with sparse([2, 3, 2, 2, 3], [1, 1, 2, 3, 3], [-1, -1, 2, -1, 1], 3, 3):
Matrix is not symmetric; cannot be an (undirected) Laplacian
[...]

julia&gt; L_out = laplacian_matrix(G; dir=:out)
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 5 stored entries:
 2  -1  -1
 ⋅   ⋅   ⋅
 ⋅  -1   1

julia&gt; SDiagonalizability._assert_matrix_is_undirected_laplacian(L_out)
ERROR: DomainError with sparse([1, 1, 3, 1, 3], [1, 2, 2, 3, 3], [2, -1, -1, -1, 1], 3, 3):
Matrix is not symmetric; cannot be an (undirected) Laplacian
[...]</code></pre><p><strong>Notes</strong></p><p>If edges are to be bidirectional, then <code>L</code> must be symmetric. <code>L</code> must also have zero row sums, since the <span>$(i, i)$</span>-th entry is the weighted degree of node <span>$i$</span> (the sum of all incident edges&#39; weights) and the <span>$(i, j)$</span>-th entry for <span>$i ≠ j$</span> is the negation of the weight of edge <span>$(i, j)$</span> (or simply <span>$0$</span>, if no such edge exists).</p><p>Given the highly optimized, lazy, zero-allocation implementation of <code>LinearAlgebra.issymmetric</code>, the symmetry check is performed first. (Both steps are <span>$O(n²)$</span> in the worst case, but testing for symmetry is far more performant in practice.) This also allows us to (also lazily) check for nonzero column sums rather than nonzero row sums (since these are equivalent for symmetric matrices) in the second step, taking advantage of Julia&#39;s column-major storage model.</p><p>At first blush, it may seem as though the choice of <code>DomainError</code> over something like <code>ArgumentError</code> (or even simply the return of a boolean) constitutes poor design. However, this is informed by the simple <em>ad hoc</em> use of this function to validate inputs for other functions requiring Laplacian matrices. Certainly, this function is never meant to be publicly exposed on its own.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/utils.jl#L81-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._classified_laplacian_01neg_spectra-Tuple{T} where T&lt;:SDiagonalizability.ClassifiedLaplacian" href="#SDiagonalizability._classified_laplacian_01neg_spectra-Tuple{T} where T&lt;:SDiagonalizability.ClassifiedLaplacian"><code>SDiagonalizability._classified_laplacian_01neg_spectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_classified_laplacian_01neg_spectra(CL) -&gt; SSpectra</code></pre><p>[TODO: Write here. Also, comment inline]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._classified_laplacian_1neg_spectra-Tuple{T} where T&lt;:SDiagonalizability.ClassifiedLaplacian" href="#SDiagonalizability._classified_laplacian_1neg_spectra-Tuple{T} where T&lt;:SDiagonalizability.ClassifiedLaplacian"><code>SDiagonalizability._classified_laplacian_1neg_spectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_classified_laplacian_1neg_spectra(CL) -&gt; SSpectra</code></pre><p>[TODO: Write here. Also, comment inline]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._classified_laplacian_s_spectra-Tuple{SDiagonalizability.ArbitraryGraphLaplacian, Tuple{Vararg{Integer}}}" href="#SDiagonalizability._classified_laplacian_s_spectra-Tuple{SDiagonalizability.ArbitraryGraphLaplacian, Tuple{Vararg{Integer}}}"><code>SDiagonalizability._classified_laplacian_s_spectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_classified_laplacian_s_spectra(CL, S) -&gt; SSpectra</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L403-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._extract_independent_cols-Tuple{AbstractMatrix{&lt;:Integer}}" href="#SDiagonalizability._extract_independent_cols-Tuple{AbstractMatrix{&lt;:Integer}}"><code>SDiagonalizability._extract_independent_cols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_extract_independent_cols(A) -&gt; Matrix{Int}</code></pre><p>Return a (not necessarily unique) independent spanning subset of the columns of <code>A</code>.</p><p>Computing a rank-revealing (pivoted) QR decomposition of <code>A</code>, the scaling coefficients from the orthogonalization process are used to determine the rank (rather than recompute it with an SVD), while the pivots are used to extract a spanning set of independent columns.</p><p>The rank-revealing Businger–Golub QR algorithm is used for the pivoting strategy, appending the &quot;most independent&quot; column with respect to the current set of pivots at each step via Householder transformations [<a href="#BG65">BG65</a>, pp. 269–70].</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{T&lt;:Integer}</code>: the matrix whose independent columns to extract.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Matrix{Int}</code>: a spanning set of independent columns of <code>A</code>.</li></ul><p><strong>Examples</strong></p><p>Observe how columns with greater Euclidean norms are given priority in the pivot ordering:</p><pre><code class="language-julia-repl hljs">julia&gt; A = [3  0  0  0  2  1   5   0
            0  3  0  0  2  1  -5   0
            0  0  3  0  2  1   5   4
            0  0  0  3  2  1   0  -4
            0  0  0  0  0  0   0   0]
5×8 Matrix{Int64}:
 3  0  0  0  2  1   5   0
 0  3  0  0  2  1  -5   0
 0  0  3  0  2  1   5   4
 0  0  0  3  2  1   0  -4
 0  0  0  0  0  0   0   0

julia&gt; SDiagonalizability._extract_independent_cols(A)
5×4 Matrix{Int64}:
  5   0  2  3
 -5   0  2  0
  5   4  2  0
  0  -4  2  0
  0   0  0  0</code></pre><p><strong>Notes</strong></p><p>Since we already need a pivoted QR decomposition to identify independent columns of <code>A</code> (or, rather, to order the columns in such a way that the first <code>rank(A)</code> ones are guaranteed to be independent), it makes sense to use data from the resulting factorization object to compute the rank of <code>A</code> rather than compute a separate SVD. We thus count the nonzero scaling coefficients—that is, the diagonal entries of the <code>R</code> matrix in <code>A = QR</code>—to determine the rank, similarly to how we count the nonzero singular values in an SVD.</p><p>It is worth noting that we manually specify a higher relative tolerance for this rank computation. Further discussion can be found in the <a href="#SDiagonalizability._rank_rtol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>_rank_rtol</code></a> documentation, but in short, a critical part of the formula for <code>LinearAlgebra.rank</code>&#39;s default <code>rtol</code> uses the minimum dimension of the input matrix. This may result in rank overestimation for tall-and-skinny and short-and-fat matrices (precisely the type we expect to encounter when dealing with all <span>$\{-1, 0, 1\}$</span>-eigenvectors of a Laplacian matrix, which is the intended use case of this helper function in this package). Our replacement tolerance, on the other hand, is a widely accepted standard in numerical analysis which uses the maximum dimension instead [<a href="#PTVF07">PTVF07</a>, p. 795].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/utils.jl#L7-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._find_basis_idxs_with_prop-Union{Tuple{K}, Tuple{AbstractVector{Int64}, K, AbstractMatrix{Int64}, Integer, Int64, Vararg{Any}}} where K&lt;:SDiagonalizability.KOrthogonality" href="#SDiagonalizability._find_basis_idxs_with_prop-Union{Tuple{K}, Tuple{AbstractVector{Int64}, K, AbstractMatrix{Int64}, Integer, Int64, Vararg{Any}}} where K&lt;:SDiagonalizability.KOrthogonality"><code>SDiagonalizability._find_basis_idxs_with_prop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_find_basis_idxs_with_prop(
    curr_idxs, prop::Orthogonality, col_space, col_rank, depth
) -&gt; Union{Nothing,AbstractVector{Int}}
_find_basis_idxs_with_prop(
    curr_idxs, prop::QuasiOrthogonality, col_space, col_rank, depth, nodes, union_find
) -&gt; Union{Nothing,AbstractVector{Int}}
_find_basis_idxs_with_prop(
    curr_idxs, prop::WeakOrthogonality, col_space, col_rank, depth, gram_matrix
) -&gt; Union{Nothing,AbstractVector{Int}}</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/basis_search.jl#L136-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._find_basis_with_property-Union{Tuple{K}, Tuple{AbstractMatrix{&lt;:Integer}, Integer, K}} where K&lt;:SDiagonalizability.KOrthogonality" href="#SDiagonalizability._find_basis_with_property-Union{Tuple{K}, Tuple{AbstractMatrix{&lt;:Integer}, Integer, K}} where K&lt;:SDiagonalizability.KOrthogonality"><code>SDiagonalizability._find_basis_with_property</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_find_basis_with_property(col_space::T, col_rank, prop) -&gt; Union{Nothing,T}</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/basis_search.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._laplacian_01neg_spectra-Tuple{AbstractMatrix{&lt;:Integer}}" href="#SDiagonalizability._laplacian_01neg_spectra-Tuple{AbstractMatrix{&lt;:Integer}}"><code>SDiagonalizability._laplacian_01neg_spectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_laplacian_01neg_spectra(L) -&gt; SSpectra</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._laplacian_1neg_spectra-Tuple{AbstractMatrix{&lt;:Integer}}" href="#SDiagonalizability._laplacian_1neg_spectra-Tuple{AbstractMatrix{&lt;:Integer}}"><code>SDiagonalizability._laplacian_1neg_spectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_laplacian_1neg_spectra(L) -&gt; SSpectra
_laplacian_1neg_spectra(spec) -&gt; SSpectra</code></pre><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._pot_kernel_01neg_eigvecs-Tuple{Integer}" href="#SDiagonalizability._pot_kernel_01neg_eigvecs-Tuple{Integer}"><code>SDiagonalizability._pot_kernel_01neg_eigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_pot_kernel_01neg_eigvecs(n) -&gt; Iterators.Flatten{&lt;:Base.Generator}</code></pre><p>Lazily compute all potential kernel <span>$\{-1, 0 ,1\}$</span>-eigenvectors of an <span>$n×n$</span> Laplacian.</p><p>Each vector is normalized so that its first nonzero entry is <span>$1$</span>, enforcing pairwise linear independence between all generated vectors.</p><p><strong>Arguments</strong></p><ul><li><code>n::Integer</code>: the order of the Laplacian matrix of some undirected graph for which to find   potential kernel eigenvectors.</li></ul><p><strong>Returns</strong></p><ul><li><code>eigvec_generator::Iterators.Flatten{&lt;:Base.Generator}</code>: a lazily evaluated iterator over   all <span>$\{-1, 0, 1\}$</span>-vectors in <span>$ℝⁿ$</span>, unique up to span.</li></ul><p><strong>Examples</strong></p><p>Generate all potential kernel eigenvectors for an order <span>$3$</span> Laplacian matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; hcat(SDiagonalizability._pot_kernel_01neg_eigvecs(3)...)
3×13 Matrix{Int64}:
  1   1   1   1  1  1   1  1  1   0  0  0  0
 -1  -1  -1   0  0  0   1  1  1   1  1  1  0
 -1   0   1  -1  0  1  -1  0  1  -1  0  1  1</code></pre><p><strong>Notes</strong></p><p>The number of potential kernel eigenvectors (unique up to span) for an order <span>$n$</span> Laplacian matrix is given by <span>$(3ⁿ - 1) / 2$</span>. See also the relevant OEIS sequence [<a href="#Slo25">Slo25</a>].</p><p>Regrettably, the implementation here is rather clunky and unidiomatic, but it is worth noting that eigenvector generation is one of two major bottlenecks in the overall <em>S</em>-bandwidth minimization algorithm. Given how much potential there is for optimization in this piece of code, we thus prioritize performance over readability in this particular case, making every effort to include inline comments wherever clarification may be needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/eigenvector_generation.jl#L73-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._pot_kernel_1neg_eigvecs-Tuple{Integer}" href="#SDiagonalizability._pot_kernel_1neg_eigvecs-Tuple{Integer}"><code>SDiagonalizability._pot_kernel_1neg_eigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_pot_kernel_1neg_eigvecs(n) -&gt; Iterators.Flatten{&lt;:Base.Generator}</code></pre><p>[TODO: Write here. Also, comment inline]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/eigenvector_generation.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._pot_nonkernel_01neg_eigvecs-Tuple{Integer}" href="#SDiagonalizability._pot_nonkernel_01neg_eigvecs-Tuple{Integer}"><code>SDiagonalizability._pot_nonkernel_01neg_eigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_pot_nonkernel_01neg_eigvecs(n) -&gt; Iterators.Flatten{&lt;:Base.Generator}</code></pre><p>Lazily compute all potential non-kernel <span>$\{-1, 0, 1\}$</span>-eigenvectors of an <span>$n×n$</span> Laplacian.</p><p>Each vector is normalized so that its first nonzero entry is <span>$1$</span>, enforcing pairwise linear independence between all generated vectors. Since all Laplacian matrices have pairwise orthogonal eigenspaces and the all-ones vector is always in the kernel, every non-kernel <span>$\{-1, 0, 1\}$</span>-eigenvector must also have an equal number of <span>$-1$</span>&#39;s and <span>$1$</span>&#39;s.</p><p><strong>Arguments</strong></p><ul><li><code>n::Integer</code>: the order of the Laplacian matrix of some undirected graph for which to find   potential non-kernel eigenvectors.</li></ul><p><strong>Returns</strong></p><ul><li><code>eigvec_generator::Iterators.Flatten{&lt;:Base.Generator}</code>: a lazily evaluated iterator over   all <span>$\{-1, 0, 1\}$</span>-vectors in <span>$ℝⁿ$</span> orthogonal to the all-ones kernel vector,   unique up to span.</li></ul><p><strong>Examples</strong></p><p>Generate all potential non-kernel eigenvectors of an order <span>$4$</span> Laplacian matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; hcat(SDiagonalizability._pot_nonkernel_01neg_eigvecs(4)...)
4×9 Matrix{Int64}:
  1   1   1   1   1   1   0   0   0
 -1   0   0  -1  -1   1   1   1   0
  0  -1   0  -1   1  -1  -1   0   1
  0   0  -1   1  -1  -1   0  -1  -1</code></pre><p><strong>Notes</strong></p><p>The number of potential non-kernel eigenvectors (unique up to span) for an order <span>$n$</span> Laplacian matrix is, by non-trivial combinatorial arguments, equal to the number of humps in all Motzkin paths of length <span>$n$</span>. See also the relevant OEIS sequence [<a href="#Deu25">Deu25</a>].</p><p>Regrettably, the implementation here is rather clunky and unidiomatic, but it is worth noting that eigenvector generation is one of two major bottlenecks in the overall <em>S</em>-bandwidth minimization algorithm. Given how much potential there is for optimization in this piece of code, we thus prioritize performance over readability in this particular case, making every effort to include inline comments wherever clarification may be needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/eigenvector_generation.jl#L162-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._pot_nonkernel_1neg_eigvecs-Tuple{Integer}" href="#SDiagonalizability._pot_nonkernel_1neg_eigvecs-Tuple{Integer}"><code>SDiagonalizability._pot_nonkernel_1neg_eigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_pot_nonkernel_1neg_eigvecs(n)</code></pre><p>[TODO: Write here. Also, comment inline]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/eigenvector_generation.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability._rank_rtol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#SDiagonalizability._rank_rtol-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>SDiagonalizability._rank_rtol</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function _rank_rtol(A::AbstractMatrix{&lt;:Real}) -&gt; Float64</code></pre><p>Return a reasonable relative tolerance for computing matrix rank via SVD or QRD.</p><p>The output is intended to be passed as a keyword argument to <code>LinearAlgebra.rank</code>. <code>LinearAlgebra.eigtype</code> is used to determine the appropriate machine epsilon for the element type of <code>A</code> when <code>eltype(A)</code> is not an <code>AbstractFloat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Real}</code>: the matrix for which to compute a tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>tol::Float64</code>: a reasonable relative tolerance for computing matrix rank via SVD or QRD.   This scales proportionally to the maximum dimension of <code>A</code>.</li></ul><p><strong>Notes</strong></p><p><code>LinearAlgebra.rank</code>&#39;s default <code>rtol</code> of <code>min(m,n) * ϵ</code> for computing the rank of an <span>$m×n$</span> matrix may result in overestimating rank when <span>$|m - n| ≫ 0$</span>, since condition number (which determines how numerically stable SVD and QRD are) grows with both dimensions [<a href="#CD05">CD05</a>, p. 603]. Given that we often deal with short-and-fat matrices in this package (particularly when processing all <span>$\{-1, 0, 1\}$</span>-eigenvectors of a Laplacian matrix), we turn instead to the same relative tolerance used by NumPy&#39;s and MATLAB&#39;s rank functions—<code>max(m,n) * ϵ</code> [<a href="#Num25">Num25</a>, <a href="#MAT25">MAT25</a>]. (Indeed, this is a widely adopted standard across the field of numerical analysis [<a href="#PTVF07">PTVF07</a>, p. 795].)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/utils.jl#L225-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.check_spectrum_integrality-Tuple{AbstractMatrix{&lt;:Integer}}" href="#SDiagonalizability.check_spectrum_integrality-Tuple{AbstractMatrix{&lt;:Integer}}"><code>SDiagonalizability.check_spectrum_integrality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_spectrum_integrality(A) -&gt; SpectrumIntegralResult</code></pre><p>Check whether the eigenvalues of <code>A</code> are integers (up to floating-point error).</p><p>If the eigenvalues are indeed all integers, then an eigenvalue-multiplicity map is constructed as well.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Integer}</code>: the matrix whose eigenvalues to check for integrality.</li></ul><p><strong>Returns</strong></p><ul><li><code>::SpectrumIntegralResult</code>: a struct containing the following fields:<ul><li><code>matrix</code>: the <code>A</code> matrix, copied to avoid shared mutability.</li><li><code>spectrum_integral</code>: whether the eigenvalues of <code>A</code> are integers.</li><li><code>multiplicities</code>: a map from each eigenvalue to its multiplicity, sorted first by   ascending multiplicity then by ascending eigenvalue. (This field is <code>nothing</code> if the   eigenvalues are not all integers.)</li></ul></li></ul><p><strong>Examples</strong></p><p>Confirm that the rotation matrix by <span>$π/2$</span> radians counterclockwise is not spectrum integral (rather, it has eigenvalues <span>$±i$</span> [<a href="#Joy15">Joy15</a>, p. 1]):</p><pre><code class="language-julia-repl hljs">julia&gt; R = Int8.([0 -1; 1 0])
2×2 Matrix{Int8}:
 0  -1
 1   0

julia&gt; res = SDiagonalizability.check_spectrum_integrality(R);

julia&gt; res.matrix
2×2 Matrix{Int64}:
 0  -1
 1   0

julia&gt; res.spectrum_integral
false

julia&gt; isnothing(res.multiplicities)
true</code></pre><p>Confirm that the adjacency matrix of the Petersen graph is spectrum integral, with correct eigenvalues and multiplicities of <span>$\{3: 1, -2: 4, 1: 5\}$</span> [<a href="#Fox09">Fox09</a>, p. 2]:</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = smallgraph(:petersen)
{10, 15} undirected simple Int64 graph

julia&gt; A = adjacency_matrix(G)
10×10 SparseArrays.SparseMatrixCSC{Int64, Int64} with 30 stored entries:
 ⋅  1  ⋅  ⋅  1  1  ⋅  ⋅  ⋅  ⋅
 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅
 ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅
 ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅
 1  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  1
 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  ⋅
 ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1
 ⋅  ⋅  1  ⋅  ⋅  1  ⋅  ⋅  ⋅  1
 ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅

julia&gt; res = SDiagonalizability.check_spectrum_integrality(A);

julia&gt; res.matrix
10×10 Matrix{Int64}:
 0  1  0  0  1  1  0  0  0  0
 1  0  1  0  0  0  1  0  0  0
 0  1  0  1  0  0  0  1  0  0
 0  0  1  0  1  0  0  0  1  0
 1  0  0  1  0  0  0  0  0  1
 1  0  0  0  0  0  0  1  1  0
 0  1  0  0  0  0  0  0  1  1
 0  0  1  0  0  1  0  0  0  1
 0  0  0  1  0  1  1  0  0  0
 0  0  0  0  1  0  1  1  0  0

julia&gt; res.spectrum_integral
true

julia&gt; res.multiplicities
OrderedCollections.OrderedDict{Int64, Int64} with 3 entries:
  3  =&gt; 1
  -2 =&gt; 4
  1  =&gt; 5</code></pre><p><strong>Notes</strong></p><p>If an undirected graph with integer edge weights is <span>$\{-1, 0, 1\}$</span>-diagonalizable (or, more restrictively, <span>$\{-1, 1\}$</span>-diagonalizable), then its Laplacian matrix has integer eigenvalues [<a href="#JP25">JP25</a>, p. 312]. Hence, validating Laplacian integrality serves as a useful screening step in this package&#39;s principal <em>S</em>-bandwidth minimization algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L26-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.classify_k_orthogonality-Tuple{Integer}" href="#SDiagonalizability.classify_k_orthogonality-Tuple{Integer}"><code>SDiagonalizability.classify_k_orthogonality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_k_orthogonality(k)</code></pre><p>Classifies the <code>k</code>-orthogonality property based on the given <code>k</code> parameter.</p><p>When searching for a <span>$k$</span>-orthogonal <em>S</em>-basis of a given Laplacian eigenspace, the family of values to which our <span>$k$</span> parameter belongs informs our choice of algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>k::Integer</code>: the <code>k</code>-orthogonality parameter to classify. Must be a positive integer.</li></ul><p><strong>Returns</strong></p><ul><li><code>::KOrthogonality</code>: An instance of a concrete <a href="#SDiagonalizability.KOrthogonality"><code>KOrthogonality</code></a> subtype   corresponding to <code>k</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>DomainError</code>: if <span>$k$</span> is not a positive integer.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SDiagonalizability.classify_k_orthogonality(1)
SDiagonalizability.Orthogonality(1)

julia&gt; SDiagonalizability.classify_k_orthogonality(2)
SDiagonalizability.QuasiOrthogonality(2)

julia&gt; SDiagonalizability.classify_k_orthogonality(3)
SDiagonalizability.WeakOrthogonality(3)

julia&gt; SDiagonalizability.classify_k_orthogonality(13)
SDiagonalizability.WeakOrthogonality(13)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/orthogonality_factory.jl#L117-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.classify_laplacian-Tuple{AbstractMatrix{&lt;:Integer}}" href="#SDiagonalizability.classify_laplacian-Tuple{AbstractMatrix{&lt;:Integer}}"><code>SDiagonalizability.classify_laplacian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_laplacian(L)</code></pre><p>Classify the Laplacian matrix <code>L</code> and wrap it in a <a href="#SDiagonalizability.ClassifiedLaplacian"><code>ClassifiedLaplacian</code></a> object.</p><p>It is first verified that <code>L</code> is indeed a Laplacian matrix by <a href="#SDiagonalizability._assert_matrix_is_undirected_laplacian-Tuple{AbstractMatrix{&lt;:Integer}}"><code>_assert_matrix_is_undirected_laplacian</code></a>, which throws a <code>DomainError</code> otherwise. It is then classified based on any properties which may be exploited in computing data on its <code>\{-1, 0, 1\}</code>-spectrum.</p><p><strong>Arguments</strong></p><ul><li><code>L::AbstractMatrix{&lt;:Integer}</code>: the Laplacian matrix to classify.</li></ul><p><strong>Returns</strong></p><ul><li><code>CL::ClassifiedLaplacian</code>: the Laplacian wrapped in a concrete   <a href="#SDiagonalizability.ClassifiedLaplacian"><code>ClassifiedLaplacian</code></a> subtype associated with the category of the   graph represented by <code>L</code>. In the case of complete graphs, <code>CL</code> also contains data on the   (necessarily uniform) weight of each edge.</li></ul><p><strong>Examples</strong></p><p>Correctly recognizes the Laplacian matrix of the null graph:</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = Graph(0)
{0, 0} undirected simple Int64 graph

julia&gt; L = laplacian_matrix(G)
0×0 SparseArrays.SparseMatrixCSC{Int64, Int64} with 0 stored entries

julia&gt; SDiagonalizability.classify_laplacian(L)
SDiagonalizability.NullGraphLaplacian(Matrix{Int64}(undef, 0, 0))</code></pre><p>Correctly recognizes the Laplacian matrix of the empty graph on <span>$3$</span> nodes:</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = Graph(3)
{3, 0} undirected simple Int64 graph

julia&gt; L = laplacian_matrix(G)
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 0 stored entries:
 ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅

julia&gt; SDiagonalizability.classify_laplacian(L)
SDiagonalizability.EmptyGraphLaplacian([0 0 0; 0 0 0; 0 0 0])</code></pre><p>Correctly recognizes the Laplacian matrix of the complete graph on <span>$4$</span> nodes:</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = complete_graph(4)
{4, 6} undirected simple Int64 graph

julia&gt; L = laplacian_matrix(G)
4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 16 stored entries:
  3  -1  -1  -1
 -1   3  -1  -1
 -1  -1   3  -1
 -1  -1  -1   3

julia&gt; SDiagonalizability.classify_laplacian(L)
SDiagonalizability.CompleteGraphLaplacian([3 -1 -1 -1; -1 3 -1 -1; -1 -1 3 -1; -1 -1 -1 3], 1)</code></pre><p>Correctly recognizes the Laplacian matrix of this random generic graph:</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = erdos_renyi(5, 8; seed=87)
{5, 8} undirected simple Int64 graph

julia&gt; L = laplacian_matrix(G)
5×5 SparseArrays.SparseMatrixCSC{Int64, Int64} with 21 stored entries:
  3   ⋅  -1  -1  -1
  ⋅   2  -1  -1   ⋅
 -1  -1   4  -1  -1
 -1  -1  -1   4  -1
 -1   ⋅  -1  -1   3

julia&gt; SDiagonalizability.classify_laplacian(L)
SDiagonalizability.ArbitraryGraphLaplacian([3 0 … -1 -1; 0 2 … -1 0; … ; -1 -1 … 4 -1; -1 0 … -1 3])</code></pre><p><strong>Notes</strong></p><p>Right now, the possible types of Laplacian matrices (or, to be more precise, the graphs they represent) are:</p><ul><li><a href="#SDiagonalizability.NullGraphLaplacian"><code>NullGraphLaplacian</code></a>: the (unique) graph with no nodes.</li><li><a href="#SDiagonalizability.EmptyGraphLaplacian"><code>EmptyGraphLaplacian</code></a>: any graph with no edges on <span>$n ≥ 1$</span> nodes.</li><li><a href="#SDiagonalizability.CompleteGraphLaplacian"><code>CompleteGraphLaplacian</code></a>: any graph on <span>$n ≥ 2$</span> nodes where every pair of nodes is   connected by an edge and all edges possess the same weight.</li><li><a href="#SDiagonalizability.ArbitraryGraphLaplacian"><code>ArbitraryGraphLaplacian</code></a>: any graph on <span>$n ≥ 3$</span> nodes with no particular   strcuture of relevance in the context of investigating <span>$\{-1, 0, 1\}$</span>-spectra.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/factories/laplacian_factory.jl#L67-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.find_k_orthogonal_basis" href="#SDiagonalizability.find_k_orthogonal_basis"><code>SDiagonalizability.find_k_orthogonal_basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_k_orthogonal_basis(
    col_space, col_rank, k, pre_basis=nothing
) -&gt; Union{Nothing,AbstractMatrix{&lt;:Integer}}</code></pre><p>Find a <code>k</code>-orthogonal spanning subset of the column set of a matrix.</p><p>This function does not allow for any <code>k</code>-orthogonal basis of <code>col_space</code> (in which case it would be trivial to construct a <em>pairwise</em> orthogonal basis via a QR decomposition). Instead, it restricts its search to spanning subsets comprised exclusively of columns already in <code>col_space</code>, returning <code>nothing</code> if no such basis exists.</p><p><strong>Arguments</strong></p><ul><li><code>col_space::T&lt;:AbstractMatrix{&lt;:Integer}</code>: the matrix whose column space is searched for a   <code>k</code>-orthogonal basis.</li><li><code>col_rank::Integer</code>: the rank of the column space of <code>col_space</code>, pre-computed for   efficiency.</li><li><code>k::Integer</code>: the minimum <span>$k$</span>-orthogonality parameter of the desired basis. Must be a   positive integer.</li><li><code>pre_basis::Union{Nothing,AbstractMatrix{&lt;:Integer}}=nothing</code>: an optional precomputed   submatrix of <code>col_space</code> whose columns form a spanning subset of the column space of   <code>col_space</code>. In case <code>col_space</code> has at most <code>k</code> columns, <code>existing_basis</code> is guaranteed   to already be a <code>k</code>-orthogonal basis and thus is used to skip unnecessary computations.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Union{Nothing,AbstractMatrix{&lt;:Integer}}</code>: a <code>k</code>-orthogonal spanning subset of the   columns of <code>col_space</code>, if one exists; otherwise, <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/basis_search.jl#L7-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.laplacian_s_spectra-Tuple{AbstractMatrix{&lt;:Integer}, Tuple{Vararg{Integer}}}" href="#SDiagonalizability.laplacian_s_spectra-Tuple{AbstractMatrix{&lt;:Integer}, Tuple{Vararg{Integer}}}"><code>SDiagonalizability.laplacian_s_spectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacian_s_spectra(L, S) -&gt; SSpectra</code></pre><p>[TODO: Write here. Also, comment inline]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/laplacian_s_spectra.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.pot_kernel_s_eigvecs-Tuple{Integer, Tuple{Vararg{Integer}}}" href="#SDiagonalizability.pot_kernel_s_eigvecs-Tuple{Integer, Tuple{Vararg{Integer}}}"><code>SDiagonalizability.pot_kernel_s_eigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pot_kernel_s_eigvecs(n, S) -&gt; Iterators.Flatten{&lt;:Base.Generator}</code></pre><p>[TODO: Write here]</p><p><strong>Arguments</strong></p><p>[TODO: Write here]</p><p><strong>Returns</strong></p><p>[TODO: Write here]</p><p><strong>Throws</strong></p><ul><li><code>DomainError</code>: if <code>n</code> is negative.</li></ul><p><strong>Examples</strong></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/eigenvector_generation.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SDiagonalizability.pot_nonkernel_s_eigvecs-Tuple{Integer, Tuple{Vararg{Integer}}}" href="#SDiagonalizability.pot_nonkernel_s_eigvecs-Tuple{Integer, Tuple{Vararg{Integer}}}"><code>SDiagonalizability.pot_nonkernel_s_eigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pot_nonkernel_s_eigvecs(n, S) -&gt; Iterators.Flatten{&lt;:Base.Generator}</code></pre><p>[TODO: Write here]</p><p><strong>Arguments</strong></p><p>[TODO: Write here]</p><p><strong>Returns</strong></p><p>[TODO: Write here]</p><p><strong>Throws</strong></p><ul><li><code>DomainError</code>: if <code>n</code> is negative.</li></ul><p><strong>Examples</strong></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GraphQuantum/SDiagonalizability.jl/blob/e06a92efe4cac3c09029ab29cb1bea194bc3f9ef/src/eigenvector_generation.jl#L40-L56">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><dl><dt>[BG65]</dt><dd><div id="BG65">P. Businger and G. H. Golub. <a href="https://doi.org/10.1007/BF01436084"><em>Linear Least Squares Solutions by Householder Transformations</em></a>. <em>Numerische Mathematik</em> <strong>7</strong>, 269–76 (1965).</div></dd><dt>[CD05]</dt><dd><div id="CD05">Z. Chen and J. Dongarra. <a href="https://doi.org/10.1137/040616413"><em>Condition Numbers of Gaussian Random Matrices</em></a>. <em>SIAM Journal on Matrix Analysis and Applications</em> <strong>27</strong>, 603–20 (2005).</div></dd><dt>[Deu25]</dt><dd><div id="Deu25">E. Deutsch. <a href="https://oeis.org/A097861"><em>Number of humps in all Motzkin paths of length n</em></a>. Entry A097861 (2025). Accessed: 2025-05-22.</div></dd><dt>[Fox09]</dt><dd><div id="Fox09">J. Fox. <a href="https://math.mit.edu/~fox/MAT307.html"><em>Lecture 19: The Petersen graph and Moore graphs</em></a>. Lecture notes, MAT 307: Combinatorics (2009). Accessed: 2025-07-25.</div></dd><dt>[JP25]</dt><dd><div id="JP25">N. Johnston and S. Plosker. <a href="https://doi.org/10.1016/j.laa.2024.10.016"><em>Laplacian {−1,0,1}- and {−1,1}-diagonalizable graphs</em></a>. <em>Linear Algebra and its Applications</em> <strong>704</strong>, 309–39 (2025).</div></dd><dt>[Joy15]</dt><dd><div id="Joy15">D. Joyce. <a href="http://aleph0.clarku.edu/~ma130/complexeigen.pdf"><em>Rotations and complex eigenvalues</em></a>. Lecture notes, Math 130: Linear Algebra (2015).</div></dd><dt>[Maf14]</dt><dd><div id="Maf14">L. O. Mafteiu-Scai. <a href="https://doi.org/10.2478/awutm-2014-0019"><em>The Bandwidths of a Matrix. A Survey of Algorithms</em></a>. <em>Annals of West University of Timisoara - Mathematics and Computer Science</em> <strong>52</strong>, 183–223 (2014).</div></dd><dt>[PTVF07]</dt><dd><div id="PTVF07">W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery. <a href="https://dl.acm.org/doi/10.5555/1403886"><em>Numerical Recipes: The Art of Scientific Computing</em></a>. 3rd Edition (Cambridge University Press, Cambridge, UK, 2007). ISBN: 978-0-521-88068-8.</div></dd><dt>[Slo25]</dt><dd><div id="Slo25">N. J. Sloane, <a href="https://oeis.org/A003462"><em>a(n) = (3^n - 1)/2</em></a>. Entry A003462 (2025). Accessed: 2025-05-22.</div></dd><dt>[VL20]</dt><dd><div id="VL20">J. J. Veerman and R. Lyons. <a href="https://doi.org/10.33581/1561-4085-2020-23-2-196-206"><em>A Primer on Laplacian Dynamics in Directed Graphs</em></a>. <em>Nonlinear Phenomena in Complex Systems</em> <strong>23</strong>, 196–206 (2020).</div></dd><dt>[MAT25]</dt><dd><div id="MAT25">MATLAB Developers, <a href="https://www.mathworks.com/help/matlab/ref/rank.html"><em>rank</em></a>. MATLAB reference documentation – R2025a (2025). Accessed: 2025-05-29.</div></dd><dt>[Num25]</dt><dd><div id="Num25">NumPy Developers, <a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_rank.html"><em>numpy.linalg.matrix_rank</em></a>. NumPy reference documentation – v2.2 (2025). Accessed: 2025-05-22.</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public_api/">« Public API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 03:25">Friday 1 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
